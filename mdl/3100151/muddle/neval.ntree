TITLE EVAL -- MUDDLE EVALUATOR

RELOCATABLE

; GERALD JAY SUSSMAN, 1971

.GLOBAL PROCID,LPROG,GLOBSP,GLOBASE,SPBASE,TPBASE,PTIME,SWAP
.GLOBAL IGVAL,CHKARG,NXTDCL,TPOVFL,CHFRM
.GLOBAL ILVAL,CALER,CALER1,ER1ARG,SPECBIND,SPECSTORE,WRONGT,ERRTMA
.GLOBAL IDVAL,EVECTO,EUVECT,CHARGS,BCKTRK,CELL
.GLOBAL PDLBUF,MESS,FACTI

.INSRT MUDDLE >

	MFUNCTION	EVAL,SUBR
	INTGO
	HLRZ	A,AB		;GET NUMBER OF ARGS
	CAIE	A,-2		;EXACTLY 1?
	JRST	AEVAL		;EVAL WITH AN ALIST
	HLRZ	A,(AB)		;GET TYPE OF ARG
	CAILE	A,NUMPRI	;PRIMITIVE?
	JRST	NONEVT		;NO
	JRST	@EVTYPT(A)	;YES-DISPATCH

SELF:	MOVE	A,(AB)		;TYPES WHICH EVALUATE 
	MOVE	B,1(AB)
	JRST	FINIS		;TO SELF-EG NUMBERS

;EVALUATES A IDENTIFIER -- GETS LOCAL VALUE IF THERE IS ONE, OTHERWISE GLOBAL.

MFUNCTION VALUE,SUBR
	JSP	E,CHKAT
	PUSHJ	P,IDVAL
	JRST	FINIS

IDVAL:	PUSH	TP,A
	PUSH	TP,B		;SAVE ARG IN CASE NEED TO CHECK GLOBAL VALUE
	PUSHJ	P,ILVAL		;LOCAL VALUE FINDER
	CAME	A,$TUNBOUND	;IF NOT UNBOUND OR UNASSIGNED
	JRST	RIDVAL		;DONE - CLEAN UP AND RETURN
	JUMPN	B,UNAS		;IF UNASSIGNED - ERROR
	POP	TP,B		;GET ARG BACK
	POP	TP,A
	PUSHJ	P,IGVAL
	CAMN	A,$TUNBOUND
	JRST	UNBOU
	POPJ	P,
RIDVAL:	SUB	TP,[2,,2]
	POPJ	P,

;GETS THE LOCAL VALUE OF AN IDENTIFIER

MFUNCTION LVAL,SUBR
	JSP	E,CHKAT
	PUSHJ	P,ILVAL
	CAMN	A,$TUNBO
	JRST	UNBOU		;UNBOUND
	CAMN	A,$TUNAS
	JRST	UNAS		;UNASSIGNED
	JRST	FINIS		;OTHER


MFUNCTION RLVAL,SUBR
	JSP	E,CHKAT
	PUSHJ	P,ILVAL
	CAMN	A,$TUNBO
	JRST	UNBOU		;STILL DON'T ALLOW UNBOUND
	JRST	FINIS		;BUT ALLOW OTHERS


MFUNCTION UNASSP,SUBR,[UNASSIGNED?]
	JSP	E,CHKAT
	PUSHJ	P,ILVAL
	CAMN	A,$TUNBO
	JRST	UNBOU
	CAME	A,$TUNAS
	JRST	IFALSE
	JRST	FINIS

; GETS A LOCATIVE TO THE LOCAL VALUE OF AN IDENTIFIER.

MFUNCTION LLOC,SUBR
	JSP	E,CHKAT
	PUSHJ	P,ILOC
	CAMN	A,$TUNBOUND
	JRST	UNBOU
	MOVSI	A,TLOCD
	HRR	A,2(B)
	JRST	FINIS

;TESTS TO SEE IF AN IDENTIFIER IS LOCALLY BOUND

MFUNCTION BOUND,SUBR,[BOUND?]
	JSP	E,CHKAT
	PUSHJ	P,ILVAL
	CAMN	A,$TUNBOUND
	JUMPE	B,IFALSE
	JRST	TRUTH

;TESTS TO SEE IF AN IDENTIFIER IS LOCALLY ASSIGNED

MFUNCTION ASSIGP,SUBR,[ASSIGNED?]
	JSP	E,CHKAT
	PUSHJ	P,ILVAL
	CAME	A,$TUNBOUND
	JRST	TRUTH
	JUMPE	B,UNBOU
	JRST	IFALSE

;GETS THE GLOBAL VALUE OF AN IDENTIFIER

MFUNCTION GVAL,SUBR
	JSP	E,CHKAT
	PUSHJ	P,IGVAL
	CAMN	A,$TUNBOUND
	JRST	UNAS
	JRST	FINIS

;GETS A LOCATIVE TO THE GLOBAL VALUE OF AN IDENTIFIER

MFUNCTION GLOC,SUBR
	JSP	E,CHKAT
	PUSHJ	P,IGLOC
	CAMN	A,$TUNBOUND
	JRST	UNAS
	MOVSI	A,TLOCD
	JRST	FINIS

;TESTS TO SEE IF AN IDENTIFIER IS GLOBALLY ASSIGNED

MFUNCTION GASSIG,SUBR,[GASSIGNED?]
	JSP	E,CHKAT
	PUSHJ	P,IGVAL
	CAMN	A,$TUNBOUND
	JRST	IFALSE
	JRST	TRUTH



CHKAT:	ENTRY	1
	HLLZ	A,(AB)
	CAME	A,$TATOM
	JRST	NONATM
	MOVE	B,1(AB)
	JRST	2,(E)

;EVALUATE A FORM. IF CAR IS AN ATOM USE GLOBAL VALUE OVER LOCAL ONE.

EVFORM:	SKIPN	C,1(AB)		;EMPTY?
	JRST	IFALSE
	HLLZ	A,(C)		;GET CAR TYPE
	CAME	A, $TATOM	;ATOMIC?
	JRST	EV0		;NO -- CALCULATE IT
	MOVE	B,1(C)		;GET PTR TO ATOM
	PUSHJ	P,IGVAL
	CAMN	A,$TUNBOUND
	JRST	LFUN
	PUSH	TP,A
	PUSH	TP,B
	JRST	IAPPLY		;APPLY IT
EV0:	PUSH	TP,A		;SET UP CAR OF FORM AND
	PUSH	TP,1(C)
	JSP	E,CHKARG
	MCALL	1,EVAL		;EVALUATE IT
	PUSH	TP,A		;APPLY THE RESULT
	PUSH	TP,B		;AS A FUNCTION
	JRST	IAPPLY

LFUN:	MOVE	B,1(AB)
	PUSH	TP,$TATOM
	PUSH	TP,1(B)
	MCALL	1,VALUE
	PUSH	TP,A
	PUSH	TP,B
	JRST	IAPPLY

;DISPATCH TABLE FOR EVAL
DISTBL EVTYPT,SELF,[[TLIST,EVLIST],[TFORM,EVFORM],[TVEC,EVECT],[TSEG,ILLSEG],[TUVEC,EUVEC]]



;WATCH FOR SUBTLE BUG 43 LERR,LPROG OR PROCID
AEVAL:
	CAIE	A,-4		;EXACTLY 2 ARGS?
	JRST	WNA		;NO-ERROR
	HLRZ	A,2(AB)		;CHECK THAT WE HAVE A FRAME
	CAIN	A,TFRAME
	JRST	.+3
	CAIE	A,TENV
	JRST	WTYP
	MOVE	A,3(AB)
	HRRZ	D,2(AB)		;GET POINTER TO PV DOPE WORD
	PUSHJ	P,SWAPQ		;SEE IF SWAP NECESSARY
	PUSH	TP,(D)
	PUSH	TP,1(D)
	MCALL	1,EVAL		;NOW DO NORMAL EVALUATION
UNSWPQ:	MOVE	D,1(TB)		;GET SAVED PVP
	CAMN	D,PVP	;CHANGED?
	JRST	FINIS		;NO - RETURN
	PUSHJ	P,SPECSTORE	;CLEAN UP
	MOVE	D,(TB)
	JSP	C,SWAP		;SWAP OUT AND BACK
	JRST	FINIS


; ROUTINE TO CHANGE PROCID AND POSSIBLY SWAP

SWAPQ:	HLRZ	C,(D)		;GET LENGTH
	SUBI	D,-1(C)		;POINT TO START OF PV
	MOVNS	C		;NEGATE LENGTH
	HRLI	D,2(C)		;MAKE AOBJN POINTER
	MOVE	E,PVP		;COPY CURRENT PROCESS VECTOR
	POP	P,B		;GET RET ADR SO POPJ WINS IF SWAP OCCURS
	CAME	D,PVP		;IS THIS IT?
	JSP	C,SWAP		;NO, SWAP IN NEW PROCESS
	PUSH	P,B		;NOW, PUT IT BACK
	PUSH	TP,$TPVP	;SAVE PROCESS
	PUSH	TP,E
	HLL	B,OTBSAV(A)	;GET TIME FROM FRAME POINTED AT
	HRR	B,A
	HRRZ	C,A
	CAIG	C,1(TP)
	CAME	B,A		;CHECK THAT THE FRAME IS LEGIT
	JRST	ILLFRA
	HLRZ	C,FSAV(C)
	CAIE	C,TENTRY
	JRST	ILLFRA
	CAMN	SP,SPSAV(A)
	JRST	AEV1
	MOVE	SP,SPSAV(A)	;LOAD UP OLD ENVIRONMENT
	MOVE	A,PVP
	ADD	A,[PROCID,,PROCID]	;GET LOCATIVE TO PROCESS ID
	PUSH	TP,BNDV		;BIND IT TO
	PUSH	TP,A
	AOSN	A,PTIME		;A UNIQUE NUMBER
	.VALUE	[ASCIZ /TIMEOUT/]
	PUSH	TP,$TFIX
	PUSH	TP,A
	PUSHJ	P,SPECBIND
AEV1:	MOVE	E,1(TB)		;GET SAVED PROCESS
	MOVE	D,AB		;COPY CURRENT ARG POINTER
	CAME	E,PVP		;HAS PROCESS CHANGED?
	MOVE	D,ABSTO+1(E)	;GET SAV AB
	POPJ	P,		;RETURN TO CALLER


; STACKFRAME FUNCTION (MUDDLE'S ANSWER TO APPLY)

	MQUOTE STACKFORM

STFRM2:	JRST	NOENV		;FAKE OUT ENTRY

MFUNCTION STACKFORM,FSUBR

	ENTRY	1

	GETYP	A,(AB)		;CHECK IT IS A LIST
	CAIE	A,TLIST
	JRST	WTYP		;NO, LOSE

	MOVEI	A,3		;CHECK ARG HAS AT LEAST 3 ELEMENTS
	HRRZ	B,1(AB)	;GET ARG
	JUMPE	B,TFA
	HRRZ	B,(B)		;CDR IT
	SOJN	A,.-2		;AND COUNT

	JUMPE	B,NOENV		;ENVIRONMENT NOT SUPPLIED
	HRRZ	A,(B)		;CHECK NOT TOO MANY
	JUMPN	A,TMA

	GETYP	A,(B)		;GET TYPE OF LAST ARG
	MOVSI	A,(A)		;TYPE TO LH
	PUSH	TP,A
	PUSH	TP,1(B)		;PUSH THE ARG
	JSP	E,CHKARG		;CHECK FOR DEFERRED
	MCALL	1,EVAL
	HLRZ	C,A		;ISOLATE TYPE IN C
	CAIE	C,TENV		;ENVIRONEMNT?
	CAIN	C,TFRAME	;OR FRAME?
	JRST	.+2
	JRST	WTYP


	MOVEI	D,(A)		;IN B AND D
	MOVE	A,B		;AND TIME,,FRAME
	PUSHJ	P,SWAPQ		;AND CHECK FOR CHANGE
	PUSH	TP,$TLIST	;SAVE THE ARG
	PUSH	TP,1(D)		;ON TP
	.MCALL	1,STFRM2	;NOW CALL NON-ENV STACKFORM
	JRST	UNSWPQ		;AND POSSIBLY UNSWAP

NOENV:	HRRZ	D,1(AB)		;GET POINTER TO FIRST
	GETYP	A,(D)		;GET TYPE
	MOVSI	A,(A)
	PUSH	TP,A
	PUSH	TP,1(D)		;PUSH THE ARG, (IT SHOULD BE A FUNCTION)
	JSP	E,CHKARG	;CHECK OUT DEFERRED
	MCALL	1,EVAL		;EVAL IT
	HRRZ	C,1(AB)		;RESTORE ARG
	HRRZ	D,(C)		;POINT TO LIST OF FORMS
	PUSH	TP,A		;SAVE FUNCTION
	PUSH	TP,B
	HLRZS	A		;NOW DISPATCH ON TYPE
	CAIN	A,TSUBR;SUBR?
	JRST	STSUBR		;YES, HACK IT
	CAIN	A,TEXPR		;FUNCTION?
	JRST	STEXPR		;YES DO IT
	CAIN	A,TFUNARG		;FUNARG
	JRST	NOTIMP
	JRST	NAPT


; STACK FORM OF A SUBR

STSUBR:	PUSH	P,[0]		;PUSH ARG COUNTER

STLOO:	PUSHJ	P,EVALRG		;EVAL THE ARGUMENT
	JRST	MAKPTR		;DONE, FALL INTO EVAL CODE
	AOS	(P)		;COUNT
	PUSH	TP,A
	PUSH	TP,B		;SAVE THE ARGS
	JRST	STLOO

; STACK FRAME OF EXPR

STEXPR:	MOVE	C,(TP)		;GET FUNCTION
	PUSHJ	P,BINDRS		;BIND THE ARGS
	JRST	APEXP1		;JOIN COMMON CODE



IAPPLY:
	HLRZ	A,(TB)		;GET TYPE OF FUNCTION
	CAIN	A,TSUBR		;SUBR?
	JRST	APSUBR		;YES
	CAIN	A,TFSUBR	;NO -- FSUBR?
	JRST	APFSUBR		;YES
	CAIN	A,TEXPR		;NO -- EXPR?
	JRST	APEXPR		;YES
	CAIN	A,TFIX		;NO -- CALL TO NTH?
	JRST	APNUM		;YES
	CAIN	A,TFUNARG	;NO -- FUNARG?
	JRST	APFUNARG	;YES
	CAIN	A,TPVP		;NO -- PROCESS TO BE RESUMED?
	JRST	RESOMER		;YES
	JRST	NAPT		;NONE OF THE ABOVE


;APFSUBR CALLS FSUBRS

APFSUBR:
	PUSH	TP,$TLIST	;GET THE
	HRRZ	A,@1(AB)
	PUSH	TP,A		;ARGUMENT LIST
	MCALL	1,@1(TB)
	JRST	FINIS

;APSUBR CALLS SUBRS

APSUBR:	
	HRRZ	A,@1(AB)	;GET CDR OF FORM -- ARGLIST
	PUSH	TP,$TLIST	;SAVE THE ARGLIST ON
	PUSH	TP,A		;THE TP
	PUSH	P,[0]		;MAKE SLOT FOR ARGCNT
TUPLUP:
	SKIPN	A,3(TB)		;IS IT NIL?
	JRST	MAKPTR		;YES -- DONE
	PUSH	TP,(A)		;NO -- GET CAR OF THE
	HLLZS	(TP)		;ARGLIST
	PUSH	TP,1(A)
	JSP	E,CHKARG
	MCALL	1,EVAL		;AND EVAL IT.
	PUSH	TP,A		;SAVE THE RESULT IN
	PUSH	TP,B		;THE GROWING TUPLE
	AOS	(P)		;BUMP THE ARGCNT
	HRRZ	A,@3(TB)	;SET THE ARGLIST TO 
	MOVEM	A,3(TB)		;CDR OF THE ARGLIST
	JRST	TUPLUP
MAKPTR:
	POP	P,A	
	ACALL	A,@1(TB)
	JRST	FINIS



;APNUM INTERPRETS NUMBERS AS CALL TO FUNCTION GET

APNUM:
	HRRZ	A,@1(AB)	;GET ARGLIST
	JUMPE	A,ERRTFA	;NO ARGUMENT
	PUSH	TP,(A)		;GET CAR OF ARGL
	HLLZS	(TP)	
	PUSH	TP,1(A)
	HRRZ	A,(A)		;MAKE SURE ONLY ONE ARG
	JUMPN	A,ERRTMA
	JSP	E,CHKARG	;HACK DEFERRED
	MCALL	1,EVAL
	PUSH	TP,A
	PUSH	TP,B
	PUSH	TP,(TB)
	PUSH	TP,1(TB)
	MCALL	2,NTH
	JRST	FINIS

;APEXPR APPLIES EXPRS
;EXPRESSION IS IN 0(AB),  FUNCTION IS IN 0(TB)

APEXPR:

	SKIPN	C,1(TB)		;BODY?
	JRST	NOBODY		;NO, ERROR
	HRRZ	0,1(AB)		;GET EXPRESSION INTO 0
	HRRZ	D,@0		;AND ARGLIST INTO D
	HLL	0,(AB)		;TYPE TO LH OF 0

	PUSHJ	P,BINDER	;DO THE BINDINGS

APEXP1:	HRRZ	C,@1(TB)	;GET BODY BACK
	JUMPE	A,DOPROG	;NOW GO RUN IF NO ACTIVIATION
	PUSH	TP,$TLIST	;SAVE ANOTHER COPY FOR REACT
	PUSH	TP,C
	SKIPL	A		;SKIP IF NOT NAME ALA HEWITT
	HRRZ	C,(C)		;ELSE CDR AGAIN
	JRST	DOPROG



RESOMER:
; 0,1(TB) IS PROCESS VECTOR POINTER TO PROCESS TO BE RESUMED
; 0,1(AB) IS A FORM CONTAINING ARGS TO SAVED FUNTION

	MOVE	D,1(TB)		;GET PVP OF PROCESS TO BE RESUMED
	GETYP	A,RESFUN(D)	; GET TYPE OF FUNCTION

	CAIN	A,TSUBR		;SUBR?
	JRST	RESSUBR		;YES
	CAIN	A,TFSUBR	;NO -- FSUBR?
	JRST	RESFSUBR		;YES
	CAIN	A,TEXPR		;NO -- EXPR?
	JRST	RESEXPR		;YES
	CAIN	A,TFIX		;NO -- CALL TO NTH?
	JRST	RESNUM		;YES
	CAIN	A,TFUNARG	;NO -- FUNARG?
	JRST	NOTIMP	;YES
	JRST	NAPT		;NONE OF THE ABOVE


;RESFSUBR RESUMES FSUBRS

RESFSUBR:
	HRRZ	A,@1(AB)	;GET THE ARG LIST
	SUB	TP,[2,,2]	;CLEAN UP
	JSP	C,SWAP		;SWAP IN NEW PROCESS
	PUSH	TP,$TLIST
	PUSH	TP,A		; PUSH THE ARG LIST
	MCALL	1,@RESFUN+1(PVP) ; RESUME WITH THE SAVED FUNCTION
	JRST	FINIS

;RESSUBR RESUMES SUBRS

RESSUBR:	
	HRRZ	A,@1(AB)	;GET CDR OF FORM -- ARGLIST
	PUSH	TP,$TLIST	;SAVE THE ARGLIST ON
	PUSH	TP,A		;THE TP
	PUSH	P,[0]		;MAKE SLOT FOR ARGCNT
RESTUPLUP:
	SKIPN	A,3(TB)		;IS IT NIL?
	JRST	RESMAKPTR		;YES -- DONE
	PUSH	TP,(A)		;NO -- GET CAR OF THE
	HLLZS	(TP)		;ARGLIST
	PUSH	TP,1(A)
	JSP	E,CHKARG
	MCALL	1,EVAL		;AND EVAL IT.
	MOVE	D,1(TB)	;GET PVP OF P.T.B.R.
	MOVE	C,TPSTO+1(D)	;GET TP OF P.T.B.R.
	PUSH	C,A		;SAVE THE RESULT IN THE GROWING
	PUSH	C,B		;TUPLE OF ARGS IN P.T.B.R.
	MOVEM	C,TPSTO+1(D)	;UPDATE TP OF P.T.B.R.
	AOS	(P)		;BUMP THE ARGCNT
	HRRZ	A,@3(TB)	;SET THE ARGLIST TO 
	MOVEM	A,3(TB)		;CDR OF THE ARGLIST
	JRST	RESTUPLUP
RESMAKPTR:
	POP	P,A		;GET NUMBER OF ARGS IN A	
	MOVE	D,1(TB)		;GET PVP OF P.T.B.R.
	SUB	TP,[4,,4]	;GET RID OF GARBAGE
	JSP	C,SWAP		;SWAP IN THE NEW PROCESS
	ACALL	A,RESFUN+1(PVP) ;CALL THE SAVED FUNCTION
	JRST	FINIS



;RESNUM INTERPRETS NUMBERS AS CALL TO FUNCTION GET

RESNUM:
	HRRZ	A,@1(AB)	;GET ARGLIST
	JUMPE	A,ERRTFA	;NO ARGUMENT
	PUSH	TP,(A)		;GET CAR OF ARGL
	HLLZS	(TP)	
	PUSH	TP,1(A)
	HRRZ	A,(A)		;MAKE SURE ONLY ONE ARG
	JUMPN	A,ERRTMA
	JSP	E,CHKARG	;HACK DEFERRED
	MCALL	1,EVAL
	MOVE	D,1(TB)		;GET PVP OF P.T.B.R.
	MOVE	C,TPSTO+1(D)	;GET TP OF P.T.B.R.
	PUSH	C,A		;PUSH ARG
	PUSH	C,B
	SUB	TP,[2,,2]	;CLEAN UP BEFORE LEAVING
	JSP	C,SWAP		;BRING IN NEW PROCESS
	PUSH	TP,RESFUN(PVP)	;PUSH NUMBER
	PUSH	TP,RESFUN+1(PVP)
	MCALL	2,NTH
	JRST	FINIS

;RESEXPR RESUMES EXPRS
;EXPRESSION IS IN 0(AB),  FUNCTION IS IN RESFUN(PVP)
RESEXPR:
	SKIPN	C,RESFUN+1(D);BODY?
	JRST	NOBODY		;NO, ERROR

	MOVE	C,TPSTO+1(D)	;GET TP OF P.T.B.R.
	PUSH	C,BNDA		;SPECIAL ATOM CROCK
	PUSH	C,MQUOTE [PPROC ],INTRUP ;PPROC=PARENT PROCESS
	MOVE	B,OTBSAV(TB)
	PUSHJ	P,MAKENV	;MAKE ENVIRONMENT FOR THIS PROCESS
	PUSH	C,A
	PUSH	C,B
	MOVEM	C,TPSTO+1(D)	;UPDATE TP OF P.T.B.R.
	HRRZ	0,1(AB)		;GET EXPRESSION INTO 0
	HRRZ	A,@0		;AND ARGLIST INTO A
	HLL	0,(AB)		;TYPE TO LH OF  0
	SUB	TP,[2,,2]	;CLEAN UP BEFORE LEAVING
	JSP	C,SWAP		;SWAP IN NEW PROCESS
	PUSH	P,0		;SAVE 0
	PUSH	P,A		;SAVE A=ARGLIST
	PUSH	TP,[0]
	PUSH	TP,[0]		;COMPLETE ARGS FOR PPROC BINDING
	PUSHJ	P,SPECBIND	;BIND THE PARENT PROCESS
	POP	P,D		;POP ARGLIST INTO D
	POP	P,0		;POP CALL HACK INTO 0
	MOVE	C,RESFUN+1(PVP)	;GET FUNCTION
	PUSHJ	P,BINDRR	;CALL BINDER FOR RESUMED EXPR HACKING

	HRRZ	C,@RESFUN+1(PVP) ;GET BODY BACK
	JUMPE	A,DOPROG	;NOW GO RUN IF NO ACTIVIATION
	PUSH	TP,$TLIST	;SAVE ANOTHER COPY FOR REACT
	PUSH	TP,C
	SKIPL	A		;SKIP IF NOT NAME ALA HEWITT
	HRRZ	C,(C)		;ELSE CDR AGAIN
	JRST	DOPROG


; EVALUATE LISTS, VECTORS, UNIFROM VECTORS

EVLIST:	PUSH	P,[-1]		;-1 -- THIS IS A LIST
	JRST	EVL1		;GO TO HACKER

EVECT:	PUSH	P,[0]		;0 -- THIS IS A GENERAL VECTOR
	JRST	EVL1

EUVEC:	PUSH	P,[1]		;1 -- THIS IS A UNIFORM VECTOR

EVL1:	PUSH	P,[0]		;PUSH A COUNTER
	GETYPF	A,(AB)		;GET FULL TYPE
	PUSH	TP,A
	PUSH	TP,1(AB)	;AND VALUE

EVL2:	INTGO			;CHECK INTERRUPTS
	SKIPN	A,1(TB)		;ANYMORE
	JRST	EVL3		;NO, QUIT
	SKIPL	-1(P)		;SKIP IF LIST
	JUMPG	A,EVL3		;JUMP IF VECTOR EMPTY
	GETYPF	B,(A)		;GET FULL TYPE
	SKIPGE	C,-1(P)		;SKIP IF NOT LIST
	HLLZS	B		;CLOBBER CDR FIELD
	JUMPG	C,EVL7		;HACK UNIFORM VECS
EVL8:	PUSH	P,B		;SAVE TYPE WORD ON P
	CAMN	B,$TSEG		;SEGMENT?
	MOVSI	B,TFORM		;FAKE OUT EVAL
	PUSH	TP,B		;PUSH TYPE
	PUSH	TP,1(A)		;AND VALUE
	MCALL	1,EVAL		;AND EVAL IT
	POP	P,C		;AND RESTORE REAL TYPE
	CAMN	C,$TSEG		;SEGMENT?
	JRST	DOSEG		;YES, HACK IT
	AOS	(P)		;COUNT ELEMENT
	PUSH	TP,A		;AND PUSH IT
	PUSH	TP,B
EVL6:	SKIPGE	A,-1(P)	;DONT SKIP IF LIST
	HRRZ	B,@1(TB)	;CDR IT
	JUMPL	A,ASTOTB	;AND STORE IT
	MOVE	B,1(TB)		;GET VECTOR POINTER
	ADD	B,AMNT(A)	;INCR BY APPROPRIATE AMOUNT
ASTOTB:	MOVEM	B,1(TB)		;AND STORE BACK
	JRST	EVL2		;AND LOOP BACK

AMNT:	2,,2			;INCR FOR GENERAL VECTOR
	1,,1			;SAME FOR UNIFORM VECTOR

CHKARG:	GETYP	A,-1(TP)
	CAIE	A,TDEFER
	JRST	(E)
	HRRZS	(TP)		;MAKE SURE INDIRECT WINS
	MOVE	A,@(TP)
	MOVEM	A,-1(TP)		;CLOBBER IN TYPE SLOT
	MOVE	A,(TP)		;NOW GET POINTER
	MOVE	A,1(A)		;GET VALUE
	MOVEM	A,(TP)		;CLOBBER IN
	JRST	(E)



EVL7:	HLRE	C,A		;FIND TYPE OF UVECTOR
	SUBM	A,C		;C POINTS TO DOPE WORD
	GETYP	B,(C)		;GET TYPE
	MOVSI	B,(B)		;TO LH NOW
	SOJA	A,EVL8		;AND RETURN TO DO EVAL

EVL3:	SKIPL	-1(P)		;SKIP IF LIST
	JRST	EVL4		;EITHER VECTOR OR UVECTOR

	MOVEI	B,0		;GET A NIL
EVL9:	MOVSI	A,TLIST		;MAKE TYPE WIN
EVL5:	SOSGE	(P)		;COUNT DOWN
	JRST	FINIS		;DONE, RETURN
	PUSH	TP,$TLIST	;SET TO CALL CONS
	PUSH	TP,B
	MCALL	2,CONS
	JRST	EVL5		;LOOP TIL DONE


EVL4:	MOVEI	B,EUVECT	;UNIFORM CASE
	SKIPG	-1(P)		;SKIP IF UNIFORM CASE
	MOVEI	B,EVECTO	;NO, GENERAL CASE
	POP	P,A		;GET COUNT
	.ACALL	A,(B)		;CALL CREATOR
	JRST	FINIS

; PROCESS SEGMENTS FOR THESE  HACKS

DOSEG:	MOVEM	A,BSTO(PVP)	;WILL BECOME INTERRUPTABLE WITH GOODIE IN B
	HLRZS	A		;TYPE TO RH
	PUSHJ	P,SAT		;GET STORAGE TYPE

	CAIN	A,S2WORD	;LIST?
	JRST	LSTSEG
	CAIN	A,S2NWORD	;GENERAL VECTOR?
	JRST	VECSEG
	CAIN	A,SNWORD	;UNIFORM VECTOR?
	JRST	UVCSEG
	CAIE	A,SARGS		;ARGS TUPLE?
	JRST	ILLSEG		;NO, ERROR

	PUSH	TP,BSTO(PVP)	;PREPARE TO CHECK ARGS
	PUSH	TP,B
	SETZM	BSTO(PVP)	;TYPE NOT SPECIAL
	MOVEI	B,-1(TP)	;POINT TO SAVED COPY
	PUSHJ	P,CHARGS	;CHECK ARG POINTER
	POP	TP,B		;AND RESTORE WINNER
	POP	TP,BSTO(PVP)	;AND TYPE AND FALL INTO VECTOR CODE

VECSEG:	PUSH	P,[2,,2]	;PUSH AMOUNT TO BUMP
	JRST	SEG1		;AND JOIN COMMON CODE

UVCSEG:	PUSH	P,[1,,1]	;AMOUNT FOR UVECTS
	JRST	SEG1



LSTSEG:	SKIPL	-1(P)		;SKIP IF IN A LIST
	JRST	SEG3		;ELSE JOIN COMMON CODE
	HRRZ	C,@1(TB)	;CHECK FOR END OF LIST
	JUMPN	C,SEG3		;NO, JOIN COMMON CODE
	SETZM	BSTO(PVP)	;CLOBBER SAVED GOODIES
	JRST	EVL9		;AND FINISH UP




SEG3:	PUSH	P,[0]		;AMOUNT OF ADDING FOR LIST
SEG1:	INTGO			;CHECK OUT INTERRUPTS
	JUMPE	B,SEG2		;DONE?
	SKIPE	C,(P)		;CHECK IF LIST OR VECTOR
	JUMPG	B,SEG2		;END OF VECTOR
	CAMN	C,[1,,1]	;SKIP IF NOT UNIFORM
	JRST	SEG5		;HACK UNIFORM SEGMENT
	GETYPF	A,(B)		;GET NEXT TYPE
	SKIPGE	-2(P)		;SKIP IF NOT LIST
	HLLZS	A		;CLEAR CDR
	MOVE	C,1(B)		;GET VALUE
SEG4:	PUSH	TP,A		;PUSH TYPE
	PUSH	TP,C
	PUSH	P,B		;CAN USE P BECAUSE CHKARG NOT INTERRUPTABLE
	JSP	E,CHKARG	;CHECK OUT TDEFER
	POP	P,B		;RESTORE
	SKIPG	(P)		;SKIP IF NOT LIST
	HRRZ	B,(B)		;CDR THE LIST
	ADD	B,(P)		;AND BUMP IT
	AOS	-1(P)		;BUMP COUNT
	JRST	SEG1		;AND DO IT AGAIN

SEG2:	SETZM	BSTO(PVP)	;CLOBBER TYPE BACK
	SUB	P,[1,,1]	;POP OFF LOSSAGE
	JRST	EVL6

SEG5:	HLRE	C,B		;FIND TYPE
	SUBM	B,C		;POINT TO DOPE WORD
	GETYP	A,(C)		;GET  TYPE 
	MOVSI	A,(A)		;TO LH
	MOVE	C,(B)		;NOW GET VALUE
	JRST	SEG4



;APFUNARG APPLIES OBJECTS OF TYPE FUNARG

APFUNARG:
	HRRZ	A,@1(TB)	;GET CDR OF FUNARG
	JUMPE	A,FUNERR	;NON -- NIL
	HLRZ	B,(A)		;GET TYPE OF CADR
	CAIE	B,TLIST		;BETTR BE LIST
	JRST	FUNERR
	PUSH	TP,$TLIST	;SAVE IT UP
	PUSH	TP,1(A)
FUNLP:
	INTGO
	SKIPN	A,3(TB)		;ANY MORE
	JRST	DOF		;NO -- APPLY IT
	HRRZ	B,(A)
	MOVEM	B,3(TB)
	HLRZ	C,(A)
	CAIE	C,TLIST
	JRST	FUNERR
	HRRZ	A,1(A)
	HLRZ	C,(A)		;GET FIRST VAR
	CAIE	C,TATOM		;MAKE SURE IT IS ATOMIC
	JRST	FUNERR
	PUSH	TP,BNDA		;SET IT UP
	PUSH	TP,1(A)
	HRRZ	A,(A)
	PUSH	TP,(A)		;SET IT UP
	PUSH	TP,1(A)
	JSP	E,CHKARG
	PUSH	TP,[0]
	PUSH	TP,[0]
	JRST	FUNLP
DOF:
	PUSHJ	P,SPECBIND	;BIND THEM
	MOVE	A,1(TB)		;GET GOODIE
	HLLZ	B,(A)
	PUSH	TP,B
	PUSH	TP,1(A)
	HRRZ	A,@1(AB)
	PUSH	TP,$TLIST
	PUSH	TP,A
	MCALL	2,CONS
	PUSH	TP,$TFORM
	PUSH	TP,B
	MCALL	1,EVAL
	JRST	FINIS


;ILOC RETURNS IN A AND B A LOCATIVE TO THE LOCAL VALUE OF THE IDENTIFIER PASSED TO IT
;IN A AND B.  IF THE IDENTIFIER IS LOCALLY UNBOUND IT RETURNS $TUNBOUND IN A AND 0 IN B,
; IT IS CALLED BY PUSHJ P,ILOC.

ILOC:	MOVSI	A,TLOCI		;MAKE A LOCATIVE TYPE CELL
	HRR	A,PROCID+1(PVP)	;FOR THE CURRENT PROCESS
	CAME	A,(B)		;IS THERE ONE IN THE VALUE CELL?
	JRST	SCHSP		;NO -- SEARCH THE LOCAL BINDINGS
	MOVE	B,1(B)		;YES -- GET LOCATIVE POINTER
	POPJ	P,		;FROM THE VALUE CELL

SCHSP:	MOVE	C,SP		;GET TOP OF BINDINGS
SCHLP:	JUMPE	C,UNPOPJ	;IF NO MORE -- LOSE
	CAMN	B,1(C)		;ARE WE POINTING AT THE WINNER?
	JRST	SCHFND		;YES
	HRRZ	C,(C)		;FOLLOW LINK
	JRST	SCHLP

SCHFND:	EXCH	B,C		;SAVE THE ATOM PTR IN C
	MOVEI	B,2(B)		;MAKE UP THE LOCATIVE
	SUBI	B,(TP)
	HRLI	B,-1(B)
	ADD	B,TP

	MOVEM	A,(C)		;CLOBBER IT AWAY INTO THE
	MOVEM	B,1(C)		;ATOM'S VALUE CELL
	POPJ	P,

UNPOPJ:	MOVSI	A,TUNBOUND
	MOVEI	B,0
	POPJ	P,

;IGLOC RETURNS IN A AND B A LOCATIVE TO THE GLOBAL VALUE OF THE 
;IDENTIFIER PASSED TO IT IN A AND B.  IF THE IDENTIFIER IS GLOBALLY
;UNBPOUND IT RETURNS $TUNBOUND IN A AND 0 IN B. IT IS CALLED BY PUSHJ P,IGLOC.

IGLOC:	MOVSI	A,TLOCI		;DO WE HAVE A LOCATIVE TO
	CAME	A,(B)		;A PROCESS #0 VALUE?
	JRST	SCHGSP		;NO -- SEARCH
	MOVE	B,1(B)		;YES -- GET VALUE CELL
	POPJ	P,

SCHGSP:	MOVE	D,GLOBSP+1(TVP)	;GET GLOBAL SP PTR

SCHG1:	JUMPGE	D,UNPOPJ	;IF NO MORE, LEAVE
	CAMN	B,1(D)		;ARE WE FOUND?
	JRST	GLOCFOUND	;YES
	ADD	D,[4,,4]	;NO -- TRY NEXT
	JRST	SCHG1

GLOCFOUND:	EXCH	B,D		;SAVE ATOM PTR
	ADD	B,[2,,2]	;MAKE LOCATIVE
	MOVEM	A,(D)		;CLOBBER IT AWAY
	MOVEM	B,1(D)
	POPJ	P,




;ILVAL RETURNS IN A AND B THE LOCAL VALUE OF THE IDENTIFIER PASSED TO IT IN A AND B
;IF THE IDENTIFIER IS UNBOUND ITS VALUE IS $TUNBOUND IN A AND 0 IN B. IF
;IT IS UNASSIGNED ITS VALUE IS $TUNBOUND IN A AND -1 IN B.  CALL - PUSHJ P,IVAL

ILVAL:
	PUSHJ	P,ILOC		;GET LOCATIVE TO VALUE
CHVAL:	CAMN	A,$TUNBOUND	;BOUND
	POPJ	P,		;NO -- RETURN
	MOVE	A,(B)		;GET THE TYPE OF THE VALUE
	MOVE	B,1(B)		;GET DATUM
	POPJ	P,

;IGVAL -- LIKE ILVAL EXCEPT FOR GLOBAL VALUES

IGVAL:	PUSHJ	P,IGLOC
	JRST	CHVAL




;BINDER - THIS SUBROUTINE PROCCESSES FUNCTION DECLARATIONS AND BINDS
;	ARGUMENTS	AND TEMPORARIES APPROPRIATELY.
;	
;	CALL:	PUSHJ	P,BINDER OR BINDRS
;
;	BINDER - ASSUMES ARGS ARE ON A LIST
;
;	BINDRS - ASSUMES FORMS SUPPLIED FOR GETTING ARGS
;	BINDRR - RESUME HACK - ARGS ON A LIST TO BE 
;		EVALED IN PARENT PROCESS
;

;	C/	POINTS TO FUNCTION BEING HACKED
;	D/	POINTS TO ARG LIST (IF <0, CALLED FROM A PROG)
;	0/	IF NON-ZERO POINTS TO EXPRESSION GENREATING CALL

BINDER:	MOVEI	A,0	
TBINDR:	PUSH	P,[ARGCDR]	;PUSH POINTER TO ARG GETTER
	JRST	BIND1

BINDRR:	MOVEI	A,0	
TBNDRR: PUSH	P,[RESARG]	; ARG GETTER FOR RESUMING FUNCTIONS
	JRST	BIND1


BINDRS:	MOVEI	A,0		;NO TOP TEMPS
TBNDRS:	PUSH	P,[SETZ EVALRG]	;FOR THE STACKFORM CASE
BIND1:	PUSH	P,[2]		;PUSH INITIAL STATE (NO DCLS PROCESSED)
	PUSH	P,A		;NUMBER OF TEMPS ON TP STACK

	JUMPE	C,NOBODY	;NO BODY IN FUNCTION, ERROR

	GETYP	A,(C)		;GET FIRST THING IN FUNCTION
	CAIE	A,TATOM		;ATOMIC?
	JRST	BIND2		;NO, NO NAME ALA HEWITT GIVEN
	PUSHJ	P,TMPUP		;COUNT TEMPS ON TP
	PUSH	TP,[TATOM,,1]	;YES SAVE IT
	PUSH	TP,1(C)
	HRRZ	C,(C)		;CDR THE FUNCTION TO POINT
	JUMPE	C,NOBODY

BIND2:	PUSHJ	P,CARLST	;MAKE SURE THE CAR IS A LIST
	JRST	BNDRET		;EXIT IMMEDIATELY
	MOVEI	A,(C)		;COPY FOR NXTDCL
	JUMPL	D,AUXDO		;PROG, HANDLE

	PUSHJ	P,NXTDCL	;GET A DECLARATION
	JRST	BINDRG		;NONE THERE, GO BIND ARGS

	CAME	B,[ASCII /BIND/]	;IS A BINDING NEEDED
	JRST	BIND3		;NO MUST BE ANOTHER FLAVOR OF DCL

	HRRZ	C,(A)		;CDR THE LIST
	JUMPE	C,MPD		;LOSER

	PUSHJ	P,CARATM	;GET THE CAR MAKING SURE OF ATOM
	JRST	MPD
	HRRZ	B,OTBSAV(TB)	;BUILD AN ENVIRONEMNT  FOR BINDING VAR
	PUSHJ	P,MAKENV

	PUSHJ	P,PSHBND	;PUSH THE BINDING ON THE STACK
	HRRZ	C,(C)		;CDR THE DCL LIST
	JRST	BINDRG		;GO BIND AS AN ARG



; MAIN BINDING LOOP, DISPATCH BASED ON DECLARATION

BIND4:	MOVEI	A,(C)		;COPY THE LIST POINTER
	PUSHJ	P,NXTDCL	;AND LOOK FOR A DECLARATION
	JRST	CHLIST		;ILLEGAL
BIND3:	TRZ	B,1		;FOR OPTIONAL TO WIN
	MOVSI	A,-DCLS		;NOW GET SET TO SEARCH TABLE
	HRRZ	C,(C)		;CDR THE DCL LIST
	JUMPE	C,MPD		;NO, CDR, ERROR

	CAMN	B,DCLST(A)	;SKIP IF NOT FOUND
	JRST	@DCLGO(A)	;DISPATCH BASED ON DCL
	AOBJN	A,.-2

	JRST	MPD

DCLS==0

DCLST:	IRP	A,,[ARGS,TUPLE,CALL,OPTIO,ACT,AUX,NAME,EXTRA]
	DCLS==DCLS+1
	ASCII /A/
	TERMIN

DCLS2==0
DCLGO:	IRP	A,,[ARGDO,TUPLDO,CALDO,OPTDO,ACTDO,AUXDO,ACTDO,AUXDO]
	A
	DCLS2==DCLS2+1
	TERMIN

IFN <DCLS-DCLS2>,PRINTC /LOSSAGE AT DCLS
/
EXPUNGE DCLS2

;HERE TO CHECK FOR LISTS WITHIN DECLARATIONS

CHLIST:	GETYP	A,(C)		;GET TYPE
	CAIE	A,TLIST		;LIST?
	JRST	MPD		;NO, LOSER
	SKIPN	A,1(C)		;CHECK NON-NIL
	JRST	CALD1		;IF NIL, IGNORE
	PUSH	TP,[TLIST,,1]	;SPECIAL TYPE
	PUSH	TP,C
	MOVEI	C,(A)		;LIST TO C
	PUSHJ	P,TMPUP		;COUNT TEMPS
	JRST	BINDRG




;HANDLER FOR CALL DECLARATION

CALDO:	SKIPL	-2(P)		;SKIP IF IN STACK-FORM
	SOSG	-1(P)		;SKIP IF FIRST DECLARATION
	JRST	MPD		;OTHERWISE MEANINGLESS

	JUMPE	0,MPD		;ALSO MEANINGLESS IF NO CALLSITE GIVEN
	PUSHJ	P,CARATD	;GOBBLE THE ATOM

	HLLZ	A,0		;SET UP CALL TO PUSH THE BINDING
	HRRZ	B,0
CALD2:	PUSHJ	P,PSHBND	;PUSH THAT BINDING ON TO STACK

CALD1:	PUSH	TP,$TLIST	;SAVE THE DCL LIST
	PUSH	TP,C
	MOVEI	E,-2(TP)	;POINT TO DCLS
	SUB	E,(P)		;SUBTRACT TEMPS
CALD3:	PUSHJ	P,SPCBE		;DO THE BINDINGS NOW
	MOVE	C,(TP)		;RESTORE DCLS
	SUB	TP,[2,,2]	;AND POP
	HRRZ	C,(C)		;CDR THE LIST
CALD4:	SETZM	-1(P)		;NEXT MUST BE EITHER AUX OR ACT
	JUMPN	C,BIND4		;LOOP AGAIN



BNDRET:	MOVEI	A,0		;SET SWITCH
BNDRT2:	SKIPN	(P)		;ANY TEMPS LEFT?
	JRST	BNDRT1
	MOVE	B,-1(TP)	;GET TYPE
	CAMN	B,[TATOM,,1]	;SPECIAL
	JRST	BNDRT3
	CAME	B,[TLIST,,1]	;STACKED LIST
	JRST	BNDRT1		;NO, LEAVE

	PUSHJ	P,TMPDWN	;TEMPS DOWN
	HRRZ	C,@(TP)	;CDR THE SAVED LIST
	SUB	TP,[2,,2]	;POP OFF CRAP
	JRST	CALD4		;AND CONTINUE PROCESSING

BNDRT3:	PUSHJ	P,TMPDWN
	MOVE	E,(TP)		;GET ATOM
	SUB	TP,[2,,2]
	MOVEI	C,0		;FOR ACTDO TO WIN
	PUSHJ	P,ACTD1
	MOVEI	A,1		;SAY NAME EXISTS

BNDRT1:	SUB	P,[3,,3]
	POPJ	P,



; HERE TO ARGS DECLARATION

ARGDO:	SOSL	-1(P)		;LOSE IF STATES ARE 0 OR 1
	SKIPGE	-2(P)		;ALSO LOSE IN STACK-FRAME
	JRST	MPD

	PUSHJ	P,CARATD	;FIND THE ATOM

	MOVSI	A,TLIST
	MOVEI	B,(D)		;COPY ARGL
	JRST	CALD2		;AND FALL INTO CALL CODE

;HERE TO HANDLE THE TUPLE DCL

TUPLDO:	SOSGE	-1(P)		;CHECK STATE
	JRST	MPD

	PUSHJ	P,CARATD	;GET ATOM
	PUSH	TP,$TLIST	;SAVE DCL LIST
	PUSH	TP,C
	PUSHJ	P,TMPUP		;COUNT THE TEMPS
	SETZB	A,B

	PUSHJ	P,PSHBND	;PUSH THE BINDING FOR THIS CHOMPER
	PUSH	P,[0]		;PUSH	ARG COUNTER

TUPLP:	PUSHJ	P,@-3(P)	;CALL ARG GOBBLING SUBROUTINE
	JRST	TUPDONE		;LEAVE IF ALL DONE

	PUSHJ	P,PSHAB		;PUSH THE EVALED ARG
	SOS	(P)		;COUNT THE ARG
	JRST	TUPLP

TUPDON:	MOVSI	A,TTB		;FENCE POST ARG BLOCK
	MOVE	B,TB		;WITH A FRAME POINTER
	PUSHJ	P,PSHAB		;ONTO THE STACK
	MOVEI	A,2		;B_ADDRESS OF INFO CELL
	PUSHJ	P,CELL"		;MAY CALL AGC
	MOVSI	A,TINFO
	MOVEM	A,(B)
	MOVEI	A,(TP)		;GENERATE DOPE WORD POINTER
	HLRE	C,TP
	SUBI	A,-1(C)
	CAME	A,TPGROW"		;ALLOWING FOR BLOWN PDL
	ADDI	A,PDLBUF
	HRLZS	A		;POINTER TO LEFT HALF...
	HLR	A,OTBSAV(TB)	;TIME TO RIGHT
	MOVEM	A,1(B)		;TO SECOND WORD OF CELL
	HRRI	A,(B)		;INFO CELL IN CDR OF ARGS VALUE CELL
	POP	P,B		;GET NUMBER OF ARGS
	ASH	B,1		;TIMES TWO
	SKIPE	B
	HRLI	B,-1(B)		;THE -1 IS TO COMPENSATE FOR CARRY
	HRRZI	C,-1(TP)
	SUB	C,(P)		;C POINTS TO TTB FENCEPOST
	HRRM	B,(C)		;STORE ARG COUNTER THERE
	ADDI	B,(C)		;BACK POINTER UP
	MOVEI	E,-1(B)		;B WIIL GET CLOBBERED, SAVE
	HRLI	A,TARGS		;GET THE RIGHT TYPE
	MOVEM	A,-4(B)		;CLOBBER IT AWAY
	MOVEM	B,-3(B)		;AND ARG POINTER

	PUSHJ	P,TMPDWN
	JRST	CALD3

; HERE TO HANDLE OPTIONAL DECLARATION

OPTDO:	SKIPG	-1(P)
	JRST	MPD		;NOT ALLOWED
	SETZM	-1(P)		;MUNG STATE
	JRST	BNDRGL		;JOIN BIND LOOP

BINDRG:	SKIPG	-1(P)		;CHECK STATE
	JRST	MPD

BNDRGL:	JUMPE	C,CHLST		;CHECK FOR LAST
	PUSH	TP,$TLIST	;SAVE DCLS
	PUSH	TP,C
	PUSH	TP,$TLIST	;SAVE SLOT
	PUSH	TP,D		;PUT ARGLIST THERE FOR AN INT CHECK
	INTGO
	MOVE	D,(TP)		;INCASE INTERRUPT CLOBBERED IT
	SETZM	(TP)		;NOW CLEAR SLOT


BNDRG3:	PUSHJ	P,CARATM	;CHECK FOR ATOM
	JRST	OPTDFL		;NO, MAY BE LIST OR MAY BE QUOTED

	PUSH	TP,$TATOM
	PUSH	TP,E		;AND ATOM

	PUSHJ	P,@-2(P)	;GOBBLE DOWN NEXT ARG
	JRST	USEDF		;CHECK FOR DEFAULT OT ENOUGH

BNDRG2:	HRRZ	C,-4(TP)	;RESTORE DCLS
	MOVE	E,(TP)		;AND ATOM
	SUB	TP,[6,,6]	;FLUSH CRAP

	PUSHJ	P,PSHBND	;PUSH THE BINDING
BNDRG4:	HRRZ	C,(C)		;CDR THE DCL LIST
	JUMPN	C,BNDRGL

CHLST:	PUSHJ	P,@-2(P)	;CHECK FOR LAST
	JRST	.+2
	JRST	TMA
	MOVEI	E,(TP)		;PREPARE TO BIND
	SUB	E,(P)
	PUSHJ	P,SPCBE		;BIND IF STUFF EXISTS
	JRST	BNDRET		;AND RETURN



CHQT:	CAIE	A,TFORM		;IST THE ARG A FORM?
	JRST	OPTDF2		;NO, END OF ARGS

	SKIPN	C,1(C)		;CHECK FOR NULL BODY
	JRST	MPD

	GETYP	A,(C)		;TYPE OF 1ST OF FORM
	MOVE	B,1(C)		;AND VALUE
	CAIN	A,TATOM		;BETTER BE ATOM
	CAME	B,MQUOTE QUOTE
	JRST	MPD		;NAMED QUOTE OR LOSSAGE
	HRRZ	C,(C)		;CDR THE FORM
	JUMPE	C,MPD		;NO, ARG LOSE
	GETYP	A,(C)
	CAIE	A,TATOM		;ARG MUST BE ATOM
	JRST	MPD
	HRRZ	A,(C)		;AND CDR BETTER BE NIL
	JUMPN	A,MPD
	PUSH	TP,$TATOM	;AND SAVE SAME
	PUSH	TP,1(C)
	SKIPGE	A,-2(P)		;CHECK TYPE OF ARGS
	JRST	QUOTHK		;STACK FRAME HACK

	JUMPE	D,USEDF		;IF NO MORE ARGS, QUIT
	GETYP	A,(D)		;GET TYPE
	MOVSI	A,(A)		;TO LH
	PUSH	TP,A		;PUSH IT UP
	PUSH	TP,1(D)		;FOR DEFER CHECK
	JSP	E,CHKARG
	POP	TP,B		;GET BACK
	POP	TP,A
	HRRZ	D,(D)		;CDR THE ARG LIST
	JRST	BNDRG2

QUOTHK:	PUSHJ	P,(A)		;CALL ROUTINE
	JRST	USEDF		;TOO FEW ARGS

	PUSH	TP,$TATOM	;QUOTE THE GOODIE
	PUSH	TP,MQUOTE QUOTE
	PUSH	TP,A
	PUSH	TP,B
	MCALL	2,LIST		;CONS IT UP
	MOVSI	A,TFORM
	JRST	BNDRG2




OPTDFL:	SKIPN	-1(P)		;SKIP IF CANT BE DEFAULT
	CAIE	A,TLIST		;SHOULD BE A LIST
	JRST	CHQT		;NO MORE OPTIONALS

	SKIPE	(TP)		;AVOID LIST OF LIST
	JRST	MPD
	MOVE	C,1(C)		;GET THE CAR
	HRRZ	A,(C)		;CDR THE LIST
	JUMPE	A,MPD		;LOSER
	HRRZ	B,(A)		;CHECK FOR NIL CDR
	JUMPN	B,MPD
	MOVEM	A,(TP)		;SAVE
	JRST	BNDRG3

OPTDF2:	JUMPN	D,OPTDF3	;IF D NON-ZERO, DONT BIND
	MOVEI	E,-4(TP)	;PREPARE TO BIND
	SUBI	E,@(P)		;SUBTRACT TEMPS
	PUSHJ	P,SPCBE		;DO BINDINGS MAYBE
	MOVEI	D,0		;RESET D TO 0
OPTDF3:	MOVE	C,-2(TP)	;RESTORE DCLS
	SUB	TP,[4,,4]	;POP STACK
	MOVEI	A,1		;CLOBBER IN A NEW STATE
	MOVEM	A,-1(P)
	JRST	BIND4		;AND RE-ENTER THE LOOP


USEDF:	SKIPE	-1(P)		;SKIP IF OPTIONAL
	JRST	TFA		;ELSE TOO FEW ARGS
	MOVEI	E,-6(TP)	;SET TO DO SPECBIND
	SUBI	E,@(P)
	PUSHJ	P,SPCBE		;BIND IF THEY EXIST
	MOVNI	B,1		;ASSUME UNASSIGNED AT FIRST
	MOVSI	A,TUNBOU
	SKIPN	C,-2(TP)	;IF A FORM TO EVAL
	JRST	OPTDF4		;TREAT NORMALLY
	GETYP	A,(C)		;EVAL IT
	MOVSI	A,(A)
	PUSH	TP,A
	PUSH	TP,1(C)
	JSP	E,CHKARG	;CHECK FOR DEFERRED POINTERS
	MCALL	1,EVAL		;EVAL IT
OPTDF4:	MOVE	E,(TP)		;GET ATOM
	MOVE	C,-4(TP)
	SUB	TP,[6,,6]	;FLUSH JUNK
	PUSHJ	P,PSHBND	;PUSH THE BINDING
	MOVEI	D,0		;MUNG ARG LIST
	JRST	BNDRG4



AUXDO:	SKIPGE	-1(P)		;CHECK STATE
	JRST	MPD
	SETOM	-1(P)		;NOTHING BUT ACT MAY FOLLOW

AUXBND:	JUMPE	C,BNDRET	;DONE
	PUSHJ	P,CARATM	;LOOK FOR ATOM
	JRST	AUXIN		;COULD BE LIST

	MOVSI	A,TUNBOU
	MOVNI	B,1
AUXB1:	PUSHJ	P,PSHBND	;PUSH THE BINDING UP

	MOVEI	E,(TP)		;PREPARE TO BIND
	PUSH	TP,$TLIST	;SAVE DCLS
	PUSH	TP,C
	SUB	E,(P)		;FUDGE FOR TEMPS
	PUSHJ	P,SPCBE

	INTGO
	HRRZ	C,@(TP)		;CDR THE LIST
	SUB	TP,[2,,2]	;AND POP
	JRST	AUXBND

AUXIN:	CAIE	A,TLIST		;IS IT A LIST
	JRST	BIND4
	PUSH	TP,$TLIST	;SAVE  DCLS
	PUSH	TP,C
	SKIPN	C,1(C)		;NIL?
	JRST	MPD		;YES, LOSE
	PUSHJ	P,CARATD	;MAKE SURE ITS AN ATOM
	PUSH	TP,$TATOM
	PUSH	TP,E
	HRRZ	C,(C)		;CDR
	JUMPE	C,MPD
	HRRZ	A,(C)		;GET NEXT CDR
	JUMPN	A,MPD		;BETTER BE NIL
	GETYP	A,(C)
	MOVSI	A,(A)		;TYPE TO LH
	PUSH	TP,A
	PUSH	TP,1(C)		;PREPARE TO EVAL
	MCALL	1,EVAL
	MOVE	E,(TP)		;RESTORE ATOM
	MOVE	C,-2(TP)	;AND DCLS
	SUB	TP,[4,,4]
	JRST	AUXB1



ACTDO:	PUSHJ	P,CARATD	;MUST BE ATOMIC
	HRRZ	C,(C)		;MUST BE END OF DCLS
	JUMPN	C,MPD
	PUSH	P,CBNDRE	;PUSH THE RIGHT RETURN

ACTD1:	MOVE	B,TB		;MAKE ENV
	PUSHJ	P,MAKENV
	HRLI	A,TACT		;AND CHANGE TO ACTIVATION
	POP	P,D		;RESTORE RET ADR, BECAUSE PSHBND NEEDS NICE STATE
	PUSHJ	P,PSHBND	;PUSH UP THE BINDING
	PUSH	P,D		;NOW PUT IT BACK
	MOVEI	E,(TP)
	SUBI	E,@-1(P)	;NOW READY TO BIND
	PUSHJ	P,SPCBE
	MOVNI	A,1		;SET SW
CBNDRE:	POPJ	P,BNDRT2


;INTERNAL ROUTINES FOR THE BINDER

TMPUP:	AOS	-1(P)		;ADDS 2 TO TOP OF STACK
	AOS	-1(P)
	POPJ	P,

TMPDWN:	SOS	-1(P)		;SUBTRACTS 2 FROM STACK
	SOS	-1(P)
	POPJ	P,

CARATD:	PUSHJ	P,CARATM	;LOOK FOR ATOM
	JRST	MPD		;ERROR IF NONE
	POPJ	P,

CARATM:	GETYP	A,(C)		;GETS ARG IN C, GET TYPE
	CAIE	A,TATOM		;ATOM?
	POPJ	P,		;NO, DONT SKIP
	MOVE	E,1(C)		;RETRUN ATOM IN E
CPOPJ1:	AOS	(P)		;SKIP RET
CPOPJ:	POPJ	P,

CARLST:	GETYP	A,(C)		;GETS LIST IN CAR, POPS TO 2D ON STACK IF NIL
	CAIE	A,TLIST
	JRST	MPD		;NOT A LIST, FATAL
	SKIPE	C,1(C)
	AOS	(P)
	POPJ	P,


MAKENV:	PUSH	P,C		;SAVE AN AC
	HLRE	C,PVP		;GET -LNTH OF PROC VECTOR
	MOVEI	A,(PVP)		;COPY PVP
	SUBI	A,-1(C)		;POINT TO DOPWD WITH A
	HRLI	A,TENV		;MAKE INTO AN ENVIRONMENT
	HLL	B,OTBSAV(B)	;TIME TO B
	POP	P,C
	POPJ	P,




; ARGCDR - NORMAL ARG GETTER FOR OTHER THAN STACKFORM

ARGCDR:	JUMPE	D,CPOPJ		;DONT SKIP IF NIL
	PUSH	TP,$TLIST
	PUSH	TP,D
	GETYP	A,(D)		;GET TYPE OF ARG
	MOVSI	A,(A)		;TO LH OF A
	PUSH	TP,A
	PUSH	TP,1(D)		;PUSH TYPE AND VALUE
	JSP	E,CHKARG	;CHECK FOR TDEFER
	MCALL	1,EVAL
	HRRZ	D,@(TP)		;CDR THE LIST
	SUB	TP,[2,,2]	;POP STACK
	JRST	CPOPJ1		;SKIP RETURN

;EVALRG - USED TO EVAL ARGS IN STACKFORM HACK

EVALRG:	JUMPE	D,CPOPJ		;LEAVE IMMEDIATELY
	PUSH	TP,$TLIST	;SAVE ARG LIST
	PUSH	TP,D
	HRRZ	C,(D)		;AND CDR IT
	GETYP	B,(C)		;GET TYPE OF CONDITIONAL FORM
	MOVSI	B,(B)		;TO LH
	PUSH	TP,B
	PUSH	TP,1(C)		;AND VALUE
	JSP	E,CHKARG	;CHECK DEFERRED
	MCALL	1,EVAL		;AND EVAL IT
	CAMN	A,$TFALSE	;FALSE?
	JRST	EVALR2		;YES, LEAVE
	HRRZ	D,(TP)		;GET ARGS BACK
	GETYP	A,(D)		;GET TYPE
	MOVSI	A,(A)		;TO LH
	PUSH	TP,A
	PUSH	TP,1(D)		;PUSH IT
	JSP	E,CHKARG	;CHECK DEFERRED
	MCALL	1,EVAL
	AOS	(P)		;CAUSE A SKIP RETURN
EVALR2:	MOVE	D,(TP)		;RESTORE ARGS
	SUB	TP,[2,,2]	;POP STACK
	POPJ	P,		;AND RETURN

;RESARG - USED TO GET ARGS FOR RESUMING FUNCTIONS


RESARG:
	JUMPE	D,CPOPJ	;DONT SKIP IF NIL - NO MORE ARGS
	PUSH	TP,$TLIST	; SAVE ARG LIST
	PUSH	TP,D
	GETYP	A,(D)		; GET TYPE OF ARG
	MOVSI	A,(A)		;TO LH
	PUSH	TP,A		;PUSH TYPE
	PUSH	TP,1(D)		;AND VALUE
	JSP	E,CHKARG	;CHECK FOR DEFERED TYPE
	MOVE	B,MQUOTE [PPROC ],INTRUP
	PUSHJ	P,ILVAL		;GET ENV OF PARENT PROCESS
	PUSH	TP,A		;SET UP FOR AEVAL CALL
	PUSH	TP,B
	MCALL	2,EVAL		;CALL EVAL WITH THE ENV
	HRRZ	D,@(TP)		;CDR ARG LIST
	SUB	TP,[2,,2]	;REMOVE SAVED ARG LIST
	JRST	CPOPJ1		;SKIP 1 AND RETURN



;SUBROUTINE TO PUSH A BINDING ON THE STACK
;	E/	ATOM
;	A/	TYPE
;	B/	VALUE

PSHBND:	PUSH	P,D		;SAVE TEMPS
	PUSH	P,E
	MOVE	D,-3(P)		;GOBBLE # OF TEMPS ON STACK
	ADD	TP,[6,,6]	;ALOCATE SPACE
	JUMPGE	TP,TPLOSE	;HACK IF OVERFLOW
PSHBN1:	HRROI	E,-6(TP)	;SET UP E
	JUMPE	D,NOBLT		;IF NO TEMPS, LESS WORK
	POP	E,6(E)		;USE POP TP MOVE THEM UP
	SOJN	D,.-1
NOBLT:	MOVSI	D,TATOM		;SET UP BINDING
	HLLOM	D,1(E)		;CLOBBER
	POP	P,2(E)		;ATOM INTO SLOT
	MOVEM	A,3(E)
	MOVEM	B,4(E)
	SETZM	5(E)		;CLEAR EXTRA SLOTS
	SETZM	6(E)
	POP	P,D
	POPJ	P,

TPLOSE:	PUSHJ	P,TPOVFL	;GO TO INT HANDLER
	JRST	PSHBN1

; DO A SPECBIND IF NEEDED

SPCBE:	MOVE	A,-5(E)		;GET TYPE
	CAME	A,BNDA
	POPJ	P,
	MOVEI	A,(TP)		;COPY POINTER
	SUBI	A,(E)		;FIND DISTANCE TO TOP
	MOVSI	A,(A)		;TO LH
	HLL	E,TP
	SUB	E,A		;FIX UP POINTER
	JRST	SPECBE		;YES, GO DO IT

;ROUTINE TO SQUEEZE A PAIR ON THE STACK

PSHAB:	PUSH	P,D
	PUSH	P,E
	PUSH	TP,[0]		;ALLOCATE SPACE
	PUSH	TP,[0]
	MOVE	D,-4(P)		;GET TEMPS COUNT
	HRROI	E,-2(TP)	;POINT TO TOP
	JUMPE	D,NOBLT1
	POP	E,2(E)
	SOJN	D,.-1

NOBLT1:	MOVEM	A,1(E)		;CLOBBER
	MOVEM	B,2(E)
	POP	P,E
	POP	P,D
	POPJ	P,



;SPECBIND BINDS IDENTIFIERS. IT IS CALLED BY PUSHJ P,SPECBIND.
;SPECBIND IS PROVIDED WITH A CONTIGUOUS SET OF TRIPLETS ON TP.  
;EACH TRIPLET IS AS FOLLOWS:
;THE FIRST ELEMENT IS THE IDENTIFIER TO BE BOUND, ITS TYPE WORD IS [TATOM,,-1],
;THE SECOND IS THE VALUE TO WHICH IT IS TO BE ASSIGNED,
;AND THE THIRD IS A PAIR OF ZEROES.

BNDA:	TATOM,,-1
BNDV:	TVEC,,-1

SPECBIND:	MOVE	E,TP		;GET THE POINTER TO TOP
SPECBE:	ADD	E,[1,,1]	;BUMP POINTER ONCE
	SETZB	0,D		;CLEAR TEMPS

BINDLP:	MOVE	A,-6(E)		;GET TYPE
	CAME	A,BNDA		;NORMAL ID BIND?
	JRST	NONID		;NO TRY BNDV

	SUB	E,[6,,6]	;MOVE PTR
	SKIPE	D		;LINK?
	HRRM	E,(D)		;YES --  LOBBER
	SKIPN	0		;UPDATED?
	MOVE	0,E		;NO -- DO IT

	MOVE	A,0(E)		;GET ATOM PTR
	MOVE	B,1(E)	
	PUSHJ	P,ILOC		;GET LAST BINDING
	HLR	A,OTBSAV (TB)	;GET TIME
	MOVEM	A,4(E)		;CLOBBER IT AWAY
	MOVEM	B,5(E)		;IN RESTORE CELLS

	HRRZ	A,PROCID+1(PVP)	;GET PROCESS NUMBER
	HRLI	A,TLOCI		;MAKE LOC PTR
	MOVE	B,E		;TO NEW VALUE
	ADD	B,[2,,2]
	MOVE	C,1(E)		;GET ATOM PTR
	MOVEM	A,(C)		;CLOBBER ITS VALUE
	MOVEM	B,1(C)		;CELL
	MOVEI	A,TBIND
	HRLM	A,(E)		;IDENTIFY AS BIND BLOCK
	MOVE	D,E		;REMEMBER LINK
	JRST	BINDLP		;DO NEXT

NONID:	MOVE	A,-4(E)		;TRY TYPE BEFORE
	CAME	A,BNDV		;IS IT A SPECIAL HACK?
	JRST	SPECBD		;NO  -- DONE
	SUB	 E,[4,,4]
	SKIPE	D
	HRRM	E,(D)
	SKIPN	0
	MOVE	0,E

	MOVE	D,1(E)		;GET PTR TO VECTOR
	MOVE	C,(D)		;EXCHANGE TYPES
	EXCH	C,2(E)
	MOVEM	C,(D)

	MOVE	C,1(D)		;EXCHANGE DATUMS
	EXCH	C,3(E)
	MOVEM	C,1(D)

	MOVEI	A,TBVL	
	HRLM	A,(E)		;IDENTIFY BIND BLOCK
	MOVE	D,E		;REMEMBER LINK
	JRST	BINDLP

SPECBD:	SKIPE	D
	HRRM	SP,(D)
	MOVE	SP,0
	POPJ	P,



;SPECSTORE RESTORES THE BINDINGS SP TO THE ENVIRONMENT POINTER IN 
;SPSAV (TB).  IT IS CALLED BY PUSHJ P,SPECSTORE.

SPECSTORE:
	HRRZ	E,SPSAV (TB)	;GET TARGET POINTER

STLOOP:
	CAIL	E,(SP)		;ARE WE DONE?
	JRST	STPOPJ
	HLRZ	C,(SP)		;GET TYPE OF BIND
	CAIE	C,TBIND		;NORMAL IDENTIFIER?
	JRST	ISTORE		;NO -- SPECIAL HACK


	MOVE	C,1(SP)		;GET TOP ATOM
	MOVE	D,4(SP)		;GET STORED LOCATIVE
	HRR	D,PROCID+1(PVP)	;STORE SIGNATURE
	MOVEM	D,(C)		;CLOBBER INTO ATOM
	MOVE	D,5(SP)
	MOVEM	D,1(C)
	SETZM	4(SP)
SPLP:	HRRZ	SP,(SP)		;FOLOW LINK
	JUMPN	SP,STLOOP	;IF MORE
	JUMPE	E,STPOPJ	;ONLY OK IF E=0
	.VALUE	[ASCIZ /SPOVERPOP/]

ISTORE:	CAIE	C,TBVL
	.VALUE	[ASCIZ /BADSP/]
	MOVE	C,1(SP)
	MOVE	D,2(SP)
	MOVEM	D,(C)
	MOVE	D,3(SP)
	MOVEM	D,1(C)
	JRST	SPLP

STPOPJ:
	MOVE	SP,SPSAV(TB)
	POPJ	P,




MFUNCTION REP,FSUBR,[REPEAT]
	JRST	PROG
MFUNCTION PROG,FSUBR
	ENTRY	1
	GETYP	A,(AB)		;GET ARG TYPE
	CAIE	A,TLIST		;IS IT A LIST?
	JRST	WTYP		;WRONG TYPE
	SKIPN	C,1(AB)		;GET AND CHECK ARGUMENT
	JRST	ERRTFA		;TOO FEW ARGS
	PUSH	TP,$TLIST	;PUSH GOODIE
	PUSH	TP,C
	PUSH	TP,BNDA		;BIND FUNNY ATOM
	PUSH	TP,MQUOTE [LPROG ],INTRUP
	PUSH	TP,$TTB
	PUSH	TP,TB		;CURRENT TB POINTER
	PUSH	TP,[0]
	PUSH	TP,[0]
	PUSHJ	P,SPECBI	;BIND THE ATOM
	MOVE	C,1(AB)		;PROG BODY
	MOVNI	D,1		;TELL BINDER WE ARE APROG
	PUSHJ	P,BINDER
	HRRZ	C,1(AB)		;RESTORE PROG
	SKIPLE	A		;SKIP IF NO NAME ALA HEWITT
	HRRZ	C,(C)
	JUMPE	C,NOBODY
	PUSH	TP,$TLIST
	PUSH	TP,C		;SAVE FOR REPEAT, AGAIN ETC.
	HRRZ	C,(C)		;SKIP DCLS
	JUMPE	C,NOBODY

; HERE TO RUN PROGS FUNCTIONS ETC.

DOPROG:
	HRRZM	C,1(TB)		;CLOBBER AWAY BODY
	PUSH	TP,(C)		;EVALUATE THE
	HLLZS	(TP)
	PUSH	TP,1(C)		;STATEMENT
	JSP	E,CHKARG
	MCALL	1,EVAL	
	HRRZ	C,@1(TB)	;GET THE REST OF THE BODY
	JUMPN	C,DOPROG	;IF MORE -- DO IT
ENDPROG:
	HRRZ	C,FSAV(TB)
	MOVE	C,@-1(C)
	CAME	C,MQUOTE REP,REPEAT
	JRST	FINIS
	SKIPN	C,(TP)		;CHECK IT
	JRST	FINIS
	MOVEM	C,1(TB)
	JRST	CONTINUE



MFUNCTION RETURN,SUBR
	ENTRY	1
	PUSHJ	P,PROGCH	;CKECK IN A PROG
	PUSHJ	P,SAVE		;RESTORE PROG'S FRAME, BCKTRKING IF NECESSARY
	MOVE	A,(AB)
	MOVE	B,1(AB)
	JRST	FINIS


MFUNCTION AGAIN,SUBR
	ENTRY	
	HLRZ	A,AB		;GET # OF ARGS
	CAIN	A,-2		;1 ARG?
	JRST	NLCLA		;YES
	JUMPN	A,WNA		;0 ARGS?
	PUSHJ	P,PROGCH	;CHECK FOR IN A PROG
	JRST	AGAD
NLCLA:	HLRZ	A,(AB)
	CAIE	A,TACT
	JRST	WTYP
	MOVE	A,1(AB)
	HRR	B,A
	HLL	B,OTBSAV (B)
	HRRZ	C,A
	CAIG	C,1(TP)
	CAME	A,B
	JRST	ILLFRA
	HLRZ	C,FSAV (C)
	CAIE	C,TENTRY
	JRST	ILLFRA
AGAD:	PUSHJ	P,SAVE		;RESTORE FRAME TO REPEAT
	MOVE	B,TPSAV(B)	;POINT TO TOP OF STACK
	MOVE	B,(B)
	MOVEM	B,1(TB)
	JRST	CONTIN

MFUNCTION GO,SUBR
	ENTRY	1
	PUSHJ	P,PROGCH	;CHECK FOR A PROG
	PUSH	TP,A		;SAVE
	PUSH	TP,B
	MOVE	A,(AB)
	CAME	A,$TATOM
	JRST	NLCLGO
	PUSH	TP,A
	PUSH	TP,1(AB)
	MOVE	B,TPSAV(B)	;GET SAVED TOP OF STACK
	PUSH	TP,-1(B)
	PUSH	TP,(B)
	MCALL	2,MEMQ		;DOES IT HAVE THIS TAG?
	JUMPE	B,NXTAG		;NO -- ERROR
FNDGO:	EXCH	B,(TP)		;SAVE PLACE TO GO
	MOVSI	D,TLIST
	MOVEM	D,-1(TP)
	JRST	GODON

NLCLGO:	CAME	A,$TTAG		;CHECK TYPE
	JRST	WTYP
	MOVE	A,1(AB)		;GET ARG
	HRR	B,3(A)
	HLL	B,OTBSAV(B)
	HRRZ	C,B
	CAIG	C,1(TP)
	CAME	B,3(A)		;CHECK TIME
	JRST	ILLFRA
	HLRZ	C,FSAV(C)
	CAIE	C,TENTRY
	JRST	ILLFRA
	PUSH	TP,(A)		;SAVE BODY
	PUSH	TP,1(A)
GODON:	PUSHJ	P,SAVE		;GO BACK TO CORRECT FRAME
	MOVE	B,(TP)		;RESTORE ITERATION MARKER
	MOVEM	B,1(TB)
	MOVE	A,(AB)
	MOVE	B,1(AB)
	JRST	CONTIN




MFUNCTION TAG,SUBR
	ENTRY	1
	HLRZ	A,(AB)		;GET TYPE OF ARGUMENT
	CAIE	A,TATOM		;CHECK THAT IT IS AN ATOM
	JRST	WTYP
	PUSHJ	P,PROGCH	;CHECK PROG
	PUSH	TP,A		;SAVE VAL
	PUSH	TP,B
	MOVE	A,TPSAV(B)	;GET STACK TOP
	PUSH	TP,0(AB)
	PUSH	TP,1(AB)
	PUSH	TP,-1(A)
	PUSH	TP,(A)
	MCALL	2,MEMQ
	JUMPE	B,NXTAG		;IF NOT FOUND -- ERROR
	MOVEM	A,-1(TP)	;SAVE PLACE
	EXCH	B,(TP)	
	MOVEI	A,1(PVP)
	HLRE	C,PVP
	SUB	A,C
	HRLI	A,TFRAME
	PUSH	TP,A
	HLL	B,OTBSAV (B)
	PUSH	TP,B
	MCALL	2,EVECTOR
	MOVSI	A,TTAG
	JRST	FINIS

PROGCH:	MOVE	B,MQUOTE [LPROG ],INTRUP
	PUSHJ	P,ILVAL		;GET VALUE
	CAME	A,$TTB		;CHECK TYPE
	JRST	NXPRG
	POPJ	P,

MFUNCTION EXIT,SUBR
	ENTRY	2
	HLRZ	A,(AB)
	CAIE	A,TACT
	JRST	WTYP
	MOVE	A,1(AB)
	HRR	B,A
	HLL	B,OTBSAV(B)
	HRRZ	C,A
	CAIG	C,1(TP)
	CAME	A,B
	JRST	ILLFRA
	HLRZ	C,FSAV(C)
	CAIE	C,TENTRY
	JRST	ILLFRA
	PUSHJ	P,SAVE		;RESTORE FRAME
	MOVE	A,2(AB)
	MOVE	B,3(AB)
	JRST	FINIS

MFUNCTION COND,FSUBR
	ENTRY	1
	HLRZ	A,(AB)
	CAIE	A,TLIST
	JRST	WTYP
	PUSH	TP,(AB)
	PUSH	TP,1(AB)		;CREATE UNNAMED TEMP
CLSLUP:	SKIPN	B,1(TB)		;IS THE CLAUSELIST NIL?
	JRST	IFALSE		;YES -- RETURN NIL
	HLRZ	A,(B)		;NO -- GET TYPE OF CAR
	CAIE	A,TLIST		;IS IT A LIST?
	JRST	BADCLS		;
	MOVE	A,1(B)		;YES -- GET CLAUSE
	JUMPE	A,BADCLS
	PUSH	TP,(A)		;EVALUATION OF
	HLLZS	(TP)
	PUSH	TP,1(A)		;THE PREDICATE
	JSP	E,CHKARG
	MCALL	1,EVAL
	CAMN	A,$TFALSE	;IF THE RESULT IS
	JRST	NXTCLS		;FALSE TRY NEXT CLAUSE
	MOVE	C,1(TB)		;IF NOT, DO FIRST CLAUSE
	MOVE	C,1(C)
	HRRZ	C,(C)
	JUMPE	C,FINIS		;(UNLESS DONE WITH IT)
	JRST	DOPROG		;AS THOUGH IT WERE A PROG
NXTCLS:	HRRZ	A,@1(TB)	;SET THE CLAUSLIST
	HRRZM	A,1(TB)		;TO CDR OF THE CLAUSLIST
	JRST	CLSLUP
	
IFALSE:
	MOVSI	A,TFALSE	;RETURN FALSE
	MOVEI	B,0
	JRST	FINIS




;RESTORE TP TO STACK FRAME POINTED TO BY B, SAVING INTERMEDIATE FRAMES ON THE PLANNER PDL 
;IF NECESSARY
SAVE:	SKIPN	C,OTBSAV(B)	;PREVIOUS FRAME?
	JRST	QWKRET
	CAMN	PP,PPSAV(C)	;ANYTHING HAPPEN TO PP BETWEEN B AND HERE?
	JRST	QWKRET		;NO-- JUST RETURN
	PUSH	TP,$TTB
	PUSH	TP,B
SVLP:	HRRZ	B,(TP)
	CAIN	B,(TB)		;DONE?
	JRST	SVRET
	HRRZ	C,OTBSAV(TB)	;ANYTHING TO SAVE YET?
	CAME	PP,PPSAV(C)
	PUSHJ	P,BCKTRK	;DO IT
	HRR	TB,OTBSAV(TB)	;AND POP UP
	JRST 	SVLP
QWKRET:	HRR	TB,B		;SKIP OVER EVERYTHING
	POPJ	P,
SVRET:	SUB	TP,[2,,2]	;POP CRAP OFF TP
	POPJ	P,

;SETG IS USED TO SET THE GLOBAL VALUE OF ITS FIRST ARGUMENT,
;AN IDENTIFIER, TO THE VALUE OF ITS SECOND ARGUMENT.  ITS VALUE IS
; ITS SECOND ARGUMENT.

MFUNCTION SETG,SUBR
	ENTRY	2
	HLLZ	A,(AB)		;GET TYPE OF FIRST ARGUMENT
	CAME	A,$TATOM	;CHECK THAT IT IS AN ATOM
	JRST	NONATM		;IF NOT -- ERROR
	MOVE	B,1(AB)		;GET POINTER TO ATOM
	PUSHJ	P,IGLOC		;GET LOCATIVE TO VALUE
	CAMN	A,$TUNBOUND	;IF BOUND
	PUSHJ	P,BSETG		;IF NOT -- BIND IT
	MOVE	C,B		;SAVE PTR
	MOVE	A,2(AB)		;GET SECOND ARGUMENT
	MOVE	B,3(AB)		;INTO THE RETURN POSITION
	MOVEM	A,(C)		;DEPOSIT INTO THE 
	MOVEM	B,1(C)		;INDICATED VALUE CELL
	JRST	FINIS

BSETG:	HRRZ	A,GLOBASE+1(TVP)
	HRRZ	B,GLOBSP+1(TVP)
	SUB	B,A
	CAIL	B,6
	JRST	SETGIT
	PUSH	TP,GLOBASE(TVP)
	PUSH	TP,GLOBASE+1 (TVP)
	PUSH	TP,$TFIX
	PUSH	TP,[0]
	PUSH	TP,$TFIX
	PUSH	TP,[100]
	MCALL	3,GROW
	MOVEM	A,GLOBASE(TVP)
	MOVEM	B,GLOBASE+1(TVP)
SETGIT:
	MOVE	B,GLOBSP+1(TVP)
	SUB	B,[4,,4]
	MOVE	C,(AB)
	MOVEM	C,(B)
	MOVE	C,1(AB)
	MOVEM	C,1(B)
	MOVEM	B,GLOBSP+1(TVP)
	ADD	B,[2,,2]
	MOVSI	A,TLOCI
	POPJ	P,




;SET CLOBBERS THE LOCAL VALUE OF THE IDENTIFIER GIVEN BY ITS
;FIRST ARGUMENT TO THE SECOND ARG.  ITS VALUE IS ITS SECOND ARGUMENT.

MFUNCTION SET,SUBR
	ENTRY	2
	HLLZ	A,(AB)		;GET TYPE OF FIRST
	CAME	A,$TATOM	;ARGUMENT -- 
	JRST	WTYP		;BETTER BE AN ATOM
	MOVE	B,1(AB)		;GET PTR TO IT
	PUSHJ	P,ILOC		;GET LOCATIVE TO VALUE
	CAMN	A,$TUNBOUND	;BOUND?
	PUSHJ	P, BSET		;BIND IT
	MOVE	C,B		;SAVE PTR
	MOVE	A,2(AB)		;GET SECOND ARG
	MOVE	B,3(AB)		;INTO RETURN VALUE
	MOVEM	A,(C)		;CLOBBER IDENTIFIER
	MOVEM	B,1(C)
	JRST	FINIS
BSET:
	HRRZ	A,TPBASE+1(PVP)	;GET ACTUAL STACK BASE
	HRRZ	B,SPBASE+1(PVP)	;AND FIRST BINDING
	SUB	B,A		;ARE THERE 6
	CAIL	B,6		;CELLS AVAILABLE?
	JRST	SETIT		;YES
	PUSH	TP,TPBASE(PVP)	;NO -- GROW THE TP
	PUSH	TP,TPBASE+1(PVP)	;AT THE BASE END
	PUSH	TP,$TFIX
	PUSH	TP,[0]
	PUSH	TP,$TFIX
	PUSH	TP,[100]
	MCALL	3,GROW
	MOVEM	A,TPBASE(PVP)	;SAVE RESULT
	MOVEM	B,TPBASE+1(PVP)
SETIT:	MOVE	B,SPBASE+1(PVP)
	MOVEI	A,-6(B)		;MAKE UP BINDING
	HRRM	A,(B)		;LINK PREVIOUS BIND BLOCK
	MOVSI	A,TBIND
	MOVEM	A,-6(B)
	MOVE	A,1(AB)
	MOVEM	A,-5(B)
	MOVSI	A,TLOCI
	HRR	A,PROCID+1(PVP)
	SUB	B,[6,,6]
	MOVEM	B,SPBASE+1(PVP)
	ADD	B,[2,,2]
	POPJ	P,



MFUNCTION NOT,SUBR
	ENTRY	1
	HLRZ	A,(AB)		; GET TYPE
	CAIE	A,TFALSE	;IS IT FALSE?
	JRST	IFALSE		;NO -- RETURN FALSE

TRUTH:
	MOVSI	A,TATOM		;RETURN T (VERITAS) 
	MOVE	B,MQUOTE T
	JRST	FINIS

MFUNCTION ANDA,FSUBR,AND
	ENTRY	1
	HLRZ	A,(AB)
	CAIE	A,TLIST
	JRST	WTYP		;IF ARG DOESN'T CHECK OUT
	SKIPN	C,1(AB)		;IF NIL
	JRST	TRUTH		;RETURN TRUTH
	PUSH	TP,$TLIST		;CREATE UNNAMED TEMP
	PUSH	TP,C
ANDLP:
	JUMPE	C,FINIS		;ANY MORE ARGS?
	MOVEM	C,1(TB)		;STORE CRUFT
	PUSH	TP,(C)		;EVALUATE THE
	HLLZS	(TP)		;FIRST REMAINING
	PUSH	TP,1(C)		;ARGUMENT
	JSP	E,CHKARG
	MCALL	1,EVAL
	CAMN	A,$TFALSE	
	JRST	FINIS		;IF FALSE -- RETURN
	HRRZ	C,@1(TB)	;GET CDR OF ARGLIST
	JRST	ANDLP

MFUNCTION OR,FSUBR
	ENTRY	1
	HLRZ	A,(AB)
	CAIE	A,TLIST		;CHECK OUT ARGUMENT
	JRST	WTYP
	MOVE	C,1(AB)		;PICK IT UP TO ENTER LOOP
	PUSH	TP,$TLIST	;CREATE UNNAMED TEMP
	PUSH	TP,C
ORLP:
	JUMPE	C,IFALSE	;IF NO MORE OPTIONS -- FALSE
	MOVEM	C,1(TB)		;CLOBBER IT AWAY
	PUSH	TP,(C)	
	HLLZS	(TP)
	PUSH	TP,1(C)		;EVALUATE THE FIRST REMAINING
	JSP	E,CHKARG
	MCALL	1,EVAL		;ARGUMENT
	CAME	A,$TFALSE	;IF NON-FALSE RETURN
	JRST	FINIS
	HRRZ	C,@1(TB)	;IF FALSE -- TRY AGAIN
	JRST	ORLP

MFUNCTION FUNCTION,FSUBR
	PUSH	TP,(AB)
	PUSH	TP,1(AB)
	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE FUNCTION
	MCALL	2,CHTYPE
	JRST	FINIS



MFUNCTION CLOSURE,SUBR
	ENTRY
	SKIPL	A,AB		;ANY ARGS
	JRST	ERRTFA		;NO -- LOSE
	ADD	A,[2,,2]	;POINT AT IDS
	PUSH	TP,$TAB
	PUSH	TP,A
	PUSH	P,[0]		;MAKE COUNTER

CLOLP:	SKIPL	A,1(TB)		;ANY MORE IDS?
	JRST	CLODON		;NO -- LOSE
	PUSH	TP,(A)		;SAVE ID
	PUSH	TP,1(A)
	PUSH	TP,(A)		;GET ITS VALUE
	PUSH	TP,1(A)
	ADD	A,[2,,2]	;BUMP POINTER
	MOVEM	A,1(TB)
	AOS	(P)
	MCALL	1,VALUE
	PUSH	TP,A
	PUSH	TP,B
	MCALL	2,LIST		;MAKE PAIR
	PUSH	TP,A
	PUSH	TP,B
	JRST	CLOLP

CLODON:	POP	P,A
	ACALL	A,LIST		;MAKE UP LIST
	PUSH	TP,(AB)		;GET FUNCTION
	PUSH	TP,1(AB)
	PUSH	TP,A
	PUSH	TP,B
	MCALL	2,LIST		;MAKE LIST
	MOVSI	A,TFUNARG
	JRST	FINIS


MFUNCTION FALSE,SUBR
	ENTRY
	JUMPGE	AB,IFALSE
	HLRZ	A,(AB)
	CAIE	A,TLIST
	JRST	WTYP
	MOVSI	A,TFALSE
	MOVE	B,1(AB)
	JRST	FINIS
;BCKTRK SAVES THE CONTENTS OF THE CURRENT FRAME OF TP ON THE PLANNER PDL
BCKTRK:	MOVSI	A,TPDL		;FOR AGC
	MOVEM	A,ASTO(PVP)
	MOVSI	C,TTP
	MOVEM	C,CSTO(PVP)

;MOVE P BLOCK OF PREVIOUS FRAME TO PP
	HRRZ	A,OTBSAV(TB)
	MOVE	C,PSAV(A)	;C _ LAST OF P "FRAME"
	HRRZ	A,OTBSAV(A)	
	PUSHJ	P,PBOT		;A _ LAST OF PREVIOUS P "FRAME"
	ADD	A,[1,,1]
MVPB:	CAMLE	A,C		;IF BLOCK EMPTY,
	JRST	MVTPB		;DO NOTHING
	HRRZ	D,C
	SUBI	D,-1(A)		;ELSE, SET COUNTER
	PUSH	PP,$TPDLS	;MARK BLOCK
	HRRM	D,(PP)
	HRLS	D
	PUSH	P,D
PSHLP1:	PUSH	PP,(A)
	INTGO		;MOVE BLOCK
	ADD	A,[1,,1]
	CAMG	A,C
	JRST	PSHLP1
	PUSH	PP,$TFIX
	PUSH	PP,[0]		;PUSH BLOCK COUNTER
	POP	P,(PP)
;NOW DO SIMILAR THING FOR TP
MVTPB:	MOVSI	A,TTP		;FOR AGC
	MOVEM	A,ASTO(PVP)
	MOVE	C,TPSAV(TB)	;C POINT TO LAST OF BLOCK
	HRRZ	A,ABSAV(TB)
	HLRE	B,C
	SUBI	B,(C)
	HRLZS	B
	HRLS	A
	ADD	A,B		;A TO FIRST
	HRRZ	D,C		;D _ NUMBER MOVED
	SUBI	D,-1(A)
	HRLS	D
	PUSH	P,D		;SAVE COUNTER
PSHLP2:	INTGO
	GETYP	B,(A)
	CAIN	B,TENTRY		;ANYTHING SPECIAL?
	JRST	MSVBLK
	CAIN	B,TBVL
	JRST	MVBVL
	CAIN	B,TBIND
	JRST	MVBND
	CAIN	B,TTB
	JRST	MVTB
	PUSH	PP,(A)		;NO, JUST MOVE IT
ARND3:	PUSH	PP,1(A)
ARND4:	ADD	A,[2,,2]
ARND1:	CAMG	A,C
	JRST	PSHLP2
	PUSH	PP,$TFIX		;PUSH BLOCK COUNTER
	PUSH	PP,[0]
	POP	P,(PP)
	HRRZ	D,(PP)		;SAVE RELATIVE PONTER TO TPSAV
	HLRE	A,ABSAV(TB)
	ADD	D,A
	SUBI	D,FRAMLN+TPSAV
	PUSH	P,D
;SAVE UNNAMED TEMPS OF PREVIOUS FRAME
	HRRZ	A,OTBSAV(TB)
	JUMPE	A,NOTEMP	;IF THERE IS ONE
	MOVE	C,TPSAV(A)
	HLRE	B,C
	SUBI	B,(C)
	HRLZS	B
	HRLS	A
	ADD	A,B		;A POINTS TO PREVIOUS FRAME
	SUB	C,[1,,1]	;C TO ITS LAST VALUE CELL
PSHLP3:	CAMLE	A,C
	JRST	NOTEMP
	GETYP	D,(C)
	CAIN	D,TTB		;SKIP--
	JRST	SKARGS		;   ARGS TUPLES
	GETYP	D,-2(C)
	CAIN	D,TBVL
	JRST	SKBVL		;   VECTOR BIND BLOCKS
	GETYP	D,-4(C)
	CAIN	D,TBIND
	JRST	SKBND		;   VARIABLE BIND BLOCKS
	PUSH	PP,(C)		;BUT SAVE UNNAMED TEMPORARIES
	PUSH	PP,1(C)
	PUSH	PP,$TTP		;AND THEIR LOCATIONS
	PUSH	PP,C
	MOVE	D,(P)		;BUMP RELATIVE POINTER TO TP
	ADDI	D,4		;SLOT
	MOVEM	D,(P)
	INTGO
ARND2:	SUB	C,[2,,2]
	JRST	PSHLP3
SKBVL:	SUB	C,[4,,4]
	JRST	PSHLP3
SKBND:	SUB	C,[6,,6]
	JRST	PSHLP3
SKARGS:	HRR	D,(C)î	HRLS	D
	ADD	C,D
	JRST	ARND2
;NOW SAVE LOCATION OF THIS FRAME
NOTEMP:	POP	P,D
	ADDI	D,2
	PUSH	PP,$TTP
	HRRM	D,(PP)		;INCLUDING TP POINTER
	PUSH	PP,A
;DONE
	MOVSI	A,TFIX		;RESET TYPES FOR AGC
	MOVEM	A,ASTO(PVP)
	MOVEM	A,CSTO(PVP)
	POPJ	P,		;RETURN

;HERE TO GET PSAV OF FRAME A; OR, IF A=0, BOTTOM OF P PDL

PBOT1:	MOVE	C,PSAV(TB)
PBOT:	SKIPE	A
	JRST	LOADP
	HLRE	D,C		;GET DOPE WORD ADDRESS IN A
	HRRZ	A,C
	SUBI	A,-1(D)
	CAME	A,PGROW"
	ADDI	A,PDLBUF		;GET PDL LENGTH IN D
	HLRZ	D,(A)
	HRLS	D		;MAKE AOBJN POINTER TO FIRST OF P
	SUBI	A,1
	SUB	A,D
	POPJ	P,		;RETURN
LOADP:	MOVE	A,PSAV(A)
	POPJ	P,

;MOVE A SAVE BLOCK

MSVBLK:	MOVSI	D,TENTS		;MAKE TYPE TENTS
	HRR	D,(A)
	PUSH	PP,D
	MOVE	D,FRAMLN+OTBSAV(A)	;RELATIVIZE OTB AND AB POINTERS
	HRRZ	E,D
	SUBI	D,(TB)
	PUSH	PP,D
	MOVE	D,FRAMLN+ABSAV(A)
	SUBI	D,(TB)
	PUSH	PP,D
	JUMPE	E,ATBOT
	PUSH	PP,SPSAV(E)	;GET EVERYTHING ELSE FROM PREVIOUS FRAME
	PUSH	PP,PSAV(E)
	PUSH	PP,TPSAV(E)
	PUSH	PP,PPSAV(E)
	PUSH	PP,PCSAV(E)
ARND11:	ADD	A,[FRAMLN,,FRAMLN]	;SKIP TO END OF BLOCK
	JRST	ARND1
;AT BOTTOM, PUSH 0'S FOR PREVIOUS FRAME'S STUFF
ATBOT:	REPEAT 5,PUSH PP,[0]
	JRST	ARND11
;MOVE A BINDING
MVBVL:	PUSH	PP,$TBVLS
	JRST	ARND3
MVBND:	PUSH	PP,$TBNDS
	JRST	ARND3
;RELATIVIZE A TB POINTER
MVTB:	MOVE	D,(A)
	HRLI	D,TTBS
	PUSH	PP,D
	MOVE	D,1(A)
	SUBI	D,(TB)
	PUSH	PP,D
	JRST	ARND4
MFUNCTION FAIL,SUBR
	ENTRY
	HLRE	A,AB
	MOVNS	A
	CAILE	A,4		;AT MOST 2 ARGS
	JRST	WNA
	CAIGE	A,2		;IF FIRST ARG NOT GIVEN, 
	JRST	MFALS		;ASSUME <>
	MOVE	B,(AB)		;OTHERWISE, FIRST ARG IS MESSAGE
	MOVEM	B,MESS(PVP)
	MOVE	B,1(AB)
	MOVEM	B,MESS+1(PVP)

	CAIE	A,4		;PLACE TO FAIL TO GIVEN?
	JRST	AFALS1
	HLRZ	A,2(AB)		;YES--DO AN "AGAIN" AND SYNCHRONIZE PP
	CAIE	A,TACT		;CAN ONLY FAIL TO AN ACTIVATION
	JRST	TAFALS
SAVACT:	MOVE	B,2(AB)		;TRANSMIT ACTIVATION TO FAILPOINT
	MOVEM	B,FACTI(PVP)		;VIA PVP
	MOVE	B,3(AB)
	MOVEM	B,FACTI+1(PVP)
;NOW REBUILD TP FROM PP
UNSAVE:	HRRZ	A,(PP)		;GET FRAME TO NESTLE IN
UNSAV1:	JUMPE	A,BDFAIL
	CAIN	A,(TB)
	JRST	START
	GETYP	B,FACTI(PVP)	;IF FALSE ACTIVATION,
	CAIN	B,TFALSE	;JUST GO TO FRAME
	JRST	POPFS
	HRRZI	B,(TB)		;OTHERWISE, CHECK TO SEE IF WE ARE LEAVING
	HRRZ	D,FACTI+1(PVP)
ALOOP:	CAIN	B,(D)		;ACTIVATION FACTI, AND IF SO,
	JRST	AFALS2		
	HRRZI	B,OTBSAV(B)
	CAIN	B,(A)
	JRST	POPFS
	JRST	ALOOP
AFALS2:	MOVSI	B,TFALSE	;SET IT TO FALSE FROM HERE ON
	MOVEM	B,FACTI(PVP)
	SETZM	FACTI+1(PVP)
POPFS:	HRR	TB,A		;MAY TAKE MORE WORK
	MOVE	AB,ABSAV(TB)
START:	HRRZ	A,OTBSAV(TB)	;RESTORE P TO STATUS
	PUSHJ	P,PBOT1		;BEFORE TB WAS ENTERED
	MOVE	P,A
	SUB	PP,[2,,2]
	HRRZ	A,1(PP)		;GET RELATIVE TP SLOT POINTER
	JUMPE	A,MHFRAM	;IF NONE, MUST HAVE FRAME ALREADY
	MOVEI	TP,2(PP)	;GROPE YOUR WAY TO IT
	SUB	TP,A
	MOVE	B,-3(TP)
	MOVEM	B,SPSAV(TB)	;REAL TRUE BINDINGS
	MOVE	TP,-1(TP)	;AND REAL TRUE STACK
	MOVEM	TP,TPSAV(TB)
	CAME	SP,B
	PUSHJ	P,SPECSTO
UNMLP2:	GETYP	A,-1(PP)
	CAIE	A,TTP
	JRST	USTPBK
	HRRZ	A,(PP)		;RESTORE AN UNNAMED TEMPORARY
	MOVE	B,-3(PP)
	MOVEM	B,(A)
	MOVE	B,-2(PP)
	MOVEM	B,1(A)
	SUB	PP,[4,,4]
	JRST	UNMLP2
;MOVE A TP BLOCK FROM PP TO TP
USTPBK:	CAIE	A,TFIX
	JRST	BADPP
	MOVSI	A,TPP
	MOVEM	A,ASTO(PVP)
	MOVE	A,PP
	SUB	A,(PP)	;A POINTS TO TOP OF BLOCK
	MOVEI	E,		;E IS A KLUDGY KOUNTER FOR HACKING BINDINGS
PSHLP4:	INTGO
	GETYP	B,-1(A)		;ANYTHING SPECIAL?
	CAIN	B,TENTS
	JRST	USVBLK
	CAIN	B,TBVLS
	JRST	USVBVL
	CAIN	B,TBNDS
	JRST	USVBND
	AOJE	E,REBIND		;IF AT END OF BLOCK, BIND THINGS
USV:	CAIN	B,TTBS
	JRST	USVTB
	PUSH	TP,-1(A)		;NO-- JUST MOVE IT
ARND7:	PUSH	TP,(A)
ARND12:	ADD	A,[2,,2]		;BUMP POINTER
ARND6:	CAMGE	A,PP
	JRST	PSHLP4
	AOJN	E,USV2		;IF FRAME ENDS WITH BIND BLOCK, BIND
	PUSHJ	P,SPECBIND
;MOVE A P BLOCK BACK TO P
USV2:	SUB	PP,(PP)
	SUB	PP,[2,,2]		;NOW BACK BEYOND TP BLOCK
	GETYP	A,-1(PP)
	CAIE	A,TFIX		;GET P BLOCK...
	JRST	CHPC2		;...IF ANY
	MOVE	A,PP
	SUB	A,(PP)		;A POINTS TO FIRST
PSHLP5:	INTGO
	PUSH	P,-1(A)		;MOVE BLOCK
	ADD	A,[1,,1]
	CAMGE	A,PP
	JRST	PSHLP5
	SUB	PP,(PP)
	SUB	PP,[3,,3]		;NOW AT NEXT PP "FRAME"
	GETYP	A,-1(PP)
CHPC2:	HRRZ	B,OTBSAV(TB)	;MAKE SURE P RESTORED
	CAME	P,PSAV(B)	;PROPERLY
	JRST	BADPP
	CAIE	A,TPC
	JRST	UNSAVE
	MOVSI	A,TFIX
	MOVEM	A,ASTO(PVP)
GOTPC:	SUB	PP,[2,,2]		;PP NOW WHERE IT SHOULD BE
	JRST	@2(PP)		;GO DO WHAT IS NECESSARY

;FRAME IS ALREADY ON THE STACK--- BINDINGS ONLY HASSLE

MHFRAM:	SKIPN	A,TPSAV(TB)	;ALL THIS STUFF TRIVIAL
	JRST	OOPS		;UNLESS NO ONE REMEMBERED TO SAVE IT	MOVE	P,PSAV(TB)
	MOVE	TP,A
	CAME	SP,SPSAV(TB)
	PUSHJ	P,SPECSTO
TSPC:	GETYP	A,-1(PP)
	CAIE	A,TPC
	JRST	BADPP
	JRST	GOTPC
OOPS:	MOVEM	TP,TPSAV(TB)	;ONLY WAY TO GET HERE IS BY
	MOVEM	P,PSAV(TB)	;FAILING BACK TO AN ABNORMALLY
	MOVEM	SP,SPSAV(TB)	;EXITED FAILPOINT
	JRST	TSPC

;HERE TO MOVE A SAVE BLOCK

USVBLK:	MOVSI	D,TENTRY
	HRR	D,-1(A)
	PUSH	TP,D
	PUSH	TP,(A)		;OTBSAV,
	PUSH	TP,1(A)		;AND ABSAV TO THIS FRAME
	MOVE	D,3(A)
	MOVEM	D,PSAV(TB)		;PSAV,
	MOVE	D,5(A)
	MOVEM	D,PPSAV(TB)		;AND PPSAV,
	MOVE	D,6(A)
	MOVEM	D,PCSAV(TB)		;AND PCSAV TO PREVIOUS FRAME
	ADD	TP,[FRAMLN-3,,FRAMLN-3]
	HRRI	TB,1(TP)		;NOW RESTORE ENVIRONMENT
	SETZM	TPSAV(TB)	;FOR OOPS: TPSAV IS EITHER GOOD OR ZERO
	MOVE	D,OTBSAV(TB)	;UNRELATIVIZING CERTAIN THINGS
	ADDI	D,(TB)
	MOVEM	D,OTBSAV(TB)
	MOVE	AB,ABSAV(TB)
	ADDI	AB,(TB)
	MOVEM	AB,ABSAV(TB)
	ADD	A,[FRAMLN,,FRAMLN]	;SKIP TO END OF BLOCK
	JRST	ARND6
;HERE TO HACK A BINDING
USVBVL:	MOVNI	E,2
	PUSH	TP,BNDV
	JRST	ARND7
USVBND:	MOVNI	E,3
	PUSH	TP,BNDA
	JRST	ARND7
;HERE TO UNRELATIVIZE A TTB
USVTB:	MOVE	D,-1(A)
	HRLI	D,TTB
	PUSH	TP,D
	MOVE	D,(A)
	ADDI	D,(TB)
	PUSH	TP,D
	JRST	ARND12;
;RESTORE BINDINGS
REBIND:	PUSH	PP,$TPP		;SAVE A ON PP
	PUSH	PP,A
	PUSHJ	P,SPECBIND	;BIND EVERYTHING ACCUMULATED ON TP
	POP	PP,A		;UNSAVE A
	SUB	PP,[1,,1]	;BACK
	GETYP	B,-1(A)		;RESTORE B
	MOVEI	E,		;RESET COUNTER
	JRST	USV
;DEFAULT MESSAGE IS <>
MFALS:	MOVSI	B,TFALSE	;TYPE FALSE
	MOVEM	B,MESS(PVP)
	SETZM	MESS+1(PVP)


;DEFAULT ACTIVATION IS <>, ALSO
AFALS1:	MOVSI	B,TFALSE
	MOVEM	B,FACTI(PVP)
	SETZM	FACTI+1(PVP)
	JRST	UNSAVE

;FALSE IS ALLOWED EXPLICITLY

TAFALS:	CAIE	A,TFALSE
	JRST	WTYP
	JRST	SAVACTMFUNCTION FAILPOINT,FSUBR,[FAILPOINT]
	ENTRY	1
	GETYP	A,(AB)		;ARGUMENT MUST BE LIST
	CAIE	A,TLIST
	JRST	WTYP
	SKIPN	C,1(AB)		;NON-NIL
	JRST	ERRTFA
	PUSH	TP,$TLIST		;SLOT FOR BODY
	PUSH	TP,[0]
	MOVE	C,1(AB)		;GET SET TO CALL BINDER
	MOVNI	D,1		;---AS A PROG
	PUSHJ	P,BINDER	;AND GO
	HRRZ	C,1(AB)		;SKIP OVER THINGS BOUND
	SKIPLE	A		;INCLUDING HEWITT ATOM IF THERE
	HRRZ	C,(C)
	JUMPE	C,NOBODY
	HRRZ	C,(C)		;C _ (EXPR -FAIL-BODY-)
	JUMPE	C,NOBODY
	PUSH	PP,$TPC		;ESTABLISH FAIL POINT
	PUSH	PP,[FP]
	HRRZ	A,(C)		;A _ ((MESS ACT) -FAIL-CLAUSES-)
	MOVEM	A,1(AB)		;SAVE FOR FAILURE
	HRRZI	A,(TB)		;GENERATE BLOCK POINTER
	MOVE	D,TP
	HLRE	B,D
	SUBI	B,(D)
	HRLZS	B
	HRLS	A
	ADD	A,B
	PUSH	PP,$TTP
	PUSH	PP,A		;SAVE LOCATION OF THIS FRAME
	PUSH	TP,(C)
	HLLZS	(TP)
	PUSH	TP,1(C)
	JSP	E,CHKARG
	MCALL	1,EVAL		;EVALUATE EXPR
	JRST	FINIS		;IF SUCCESSFUL, DO NORMAL FINIS

;FAIL TO HERE--BIND MESSAGE AND ACTIVATION

FP:	HRRZ	A,1(AB)
	GETYP	C,(A)
	CAIE	C,TLIST
	JRST	MPD
	HRRZ	C,1(A)		;C _ (MESS ACT)
	JUMPE	C,MPD
	PUSHJ	P,CARATM	;E _ MESS
	JRST 	MPD		;MUST BE ATOM
	PUSH	TP,BNDA
	PUSH	TP,E
	HRRZ	C,(C)		;DO A CDR
	JUMPE	C,MPD
	PUSHJ	P,CARATM		;E _ ACT
	JRST	MPD		;MUST ALSO BE ATOM
	PUSH	TP,MESS(PVP)
	PUSH	TP,MESS+1(PVP)
	PUSH	TP,[0]
	PUSH	TP,[0]
	PUSH	TP,BNDA
	PUSH	TP,E
	PUSH	TP,FACTI(PVP)
	PUSH	TP,FACTI+1(PVP)
	PUSH	TP,[0]
	PUSH	TP,[0]
	PUSHJ	P,SPECBIND
	INTGO			;JUST IN CASE
	
;GET CLAUSES AND BEGIN

SLOOP:	HRRZ	C,1(AB)
	HRRZ	C,(C)
	HRRZM	C,1(TB)		;C _ (-FAIL-CLAUSES-)
CLOOP1:	SKIPN	B,1(TB)		;IF CLAUSELIST NIL,
	JRST	REFAIL		;FAIL
	GETYP	A,(B)		;NO-- GET TYPE OF CAR
	CAIE	A,TLIST		;LIST?
	JRST	BADCLS
	MOVE	A,1(B)		;A IS CLAUSE
	JUMPE	A,BADCLS		;WHICH MUST BE NON-NIL
	PUSH	TP,(A)		;GET PREDICATE
	HLLZS	(TP)
	PUSH	TP,1(A)
	JSP	E,CHKARG
	MCALL	1,EVAL		;EVALUATE IT
	CAMN	A,$TFALSE
	JRST	NXCLS1		;IF FALSE, TRY NEXT
	MOVE	C,1(TB)		;ELSE, EVALUATE REST OF CLAUSE
	MOVE	C,1(C)
	HRRZ	C,(C)
	JUMPE	C,REFAIL	;IF NONE, FAIL
DOFC:	HRRZM	C,1(TB)		;ELSE DO LIKE A PROG
	PUSH	TP,(C)		;GET CAR OF CLAUSE
	HLLZS	(TP)
	PUSH	TP,1(C)
	JSP	E,CHKARG
	MCALL	1,EVAL		;EVALUATE IT
	HRRZ	C,@1(TB)
	JUMPN	C,DOFC		;DO AGAIN
	JRST	REFAIL		;ELSE FAIL
NXCLS1:	HRRZ	A,@1(TB)	;CDR CLAUSELIST
	HRRZM	A,1(TB)
	JRST	CLOOP1î;IF NO MORE CLAUSES, KEEP FAILING
RFAIL2:	MOVE	AB,ABSAV(TB)	;RESTORE ENTIRE FRAME
REFAIL:	PUSH	TP,-11(TP)	;FAIL WITH SAME MESSAGE	
	PUSH	TP,-11(TP)
	PUSH	TP,-5(TP)	;AND ACTIVATION
	PUSH	TP,-5(TP)
	MCALL	2,FAIL

MFUNCTION RESTORE,SUBR,[RESTORE]

	ENTRY
	HLRE	A,AB
	MOVNS	A
	CAIG	A,4		;1 OR 2 ARGUMENTS
	CAIGE	A,2
	JRST	WNA
	PUSHJ	P,TILLFM	;B _ FRAME TO RESTORE (IF LEGAL)
	HRRZ	C,FSAV(B)
	CAIE	C,FAILPO	;ONLY FAILPOINTS RESTORABLE
	JRST	ILLFRA
	PUSHJ	P,SAVE		;RESTORE IT
	MOVE	TP,TPSAV(TB)
	MOVE	P,PSAV(TB)
	CAME	SP,SPSAV(TB)
	PUSHJ	P,SPECSTO
	GETYP	C,-3(TP)	;WAS ACT <> AT THIS POINT?
	CAIE	C,TFALSE
	JRST	RFAIL2		;IF NOT, KEEP FAILING
	HLRE	C,AB		;YES, GET VALUE TO RETURN
	MOVNS	C
	CAIE	C,4		;VALUE GIVEN?
	JRST	VFALS		;IF NOT, ASSUME <>
	MOVE	A,2(AB)
	MOVE	B,3(AB)
	JRST	RSFP
VFALS:	MOVE	A,$TFALSE
	MOVEI	B,
RSFP:	MOVE	AB,ABSAV(TB)
	PUSH	PP,$TPC
	PUSH	PP,[FP2]
	JRST	FINIS


;FAIL HERE ON RESTORED FAILPOINTS (M AND A ALREADY BOUND)

FP2:	MOVE	C,MESS(PVP)		;SET MESSAGE...
	MOVEM	C,-11(TP)
	MOVE	C,MESS+1(PVP)
	MOVEM	C,-10(TP)
	MOVE	C,FACTI(PVP)	;...AND ACTIVATION
	MOVEM	C,-3(TP)
	MOVE	C,FACTI+1(PVP)
	MOVEM	C,-2(TP)
	JRST	SLOOPMFUNCTION FINALIZE,SUBR,[FINALIZE]
	ENTRY	1
	PUSHJ	P,TILLFM	;MAKE SURE ARG IS LEGAL
	HRR	B,OTBSAV(B)	;B _ FRAME BEFORE ACTIVATION
	MOVE	PP,PPSAV(B)	;RESTORE PP
	HRRZ	A,TB		;IN EVERY FRAME
FLOOP:	CAIN	A,(B)		;FOR EACH ONE,
	JRST	FDONE
	MOVEM	PP,PPSAV(A)
	HRR	A,OTBSAV(A)
	JRST	FLOOP
FDONE:	MOVE	A,$TFALSE
	MOVEI	B,
	JRST	FINIS	

;TILLFM SETS B _ FIRST ARGUMENT IFF IT IS A LEGAL ACTIVATION

TILLFM:	HLRZ	A,(AB)		;FIRST ARG MUST BE ACTIVATION
	CAIE	A,TACT
	JRST	WTYP
	MOVE	A,1(AB)		;WITH RIGHT TIME
	HRR	B,A
	HLL	B,OTBSAV(B)
	HRRZ	C,A		;AND PLACE
	CAIG	C,1(TP)
	CAME	A,B
	JRST	ILLFRA
	GETYP	C,FSAV(C)	;AND STRUCTURE
	CAIE	C,TENTRY
	JRST	ILLFRA
	POPJ	P,

;ERROR COMMENTS FOR EVAL

UNBOU:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE UNBOUND-VARIABLE
	JRST	ER1ARG

UNAS:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE UNASSIGNED-VARIABLE
	JRST	ER1ARG

TFA:
ERRTFA:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE TOO-FEW-ARGUMENTS-SUPPLIED
	JRST	CALER1

TMA:
ERRTMA:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE TOO-MANY-ARGUMENTS-SUPPLIED
	JRST	CALER1

BADENV:
	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE BAD-ENVIRONMENT
	JRST	CALER1

FUNERR:
	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE BAD-FUNARG
	JRST	CALER1

WRONGT:
WTYP:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE WRONG-TYPE
	JRST	CALER1

MPD:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE MEANINGLESS-PARAMETER-DECLARATION
	JRST	CALER1

NOBODY:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE HAS-EMPTY-BODY
	JRST	CALER1

BADCLS:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE BAD-CLAUSE
	JRST	CALER1

NXTAG:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE NON-EXISTENT-TAG
	JRST	CALER1

NXPRG:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE NOT-IN-PROG
	JRST	CALER1

NAPT:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE NON-APPLICABLE-TYPE
	JRST	CALER1

NONEVT:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE NON-EVALUATEABLE-TYPE
	JRST	CALER1


NONATM:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE NON-ATOMIC-ARGUMENT
	JRST	CALER1


ILLFRA:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE FRAME-NO-LONGER-EXISTS
	JRST	CALER1

NOTIMP:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE NOT-YEST-IMPLEMENTED
	JRST	CALER1

ILLSEG:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE ILLEGAL-SEGMENT
	JRST	CALER1

BADPP:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE PP-IN-ILLEGAL-CONFIGURATION
	JRST	CALER1


BDFAIL:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE OVERPOP--FAIL
	JRST	CALER1


ER1ARG:	PUSH	TP,(AB)
	PUSH	TP,1(AB)
	MOVEI	A,2
	JRST	CALER
CALER1:	MOVEI	A,1
CALER:
	HRRZ	C,FSAV(TB)
	PUSH	TP,$TATOM
	PUSH	TP,@-1(C)
	ADDI	A,1
	ACALL	A,ERROR
	JRST	FINIS
  
END
***